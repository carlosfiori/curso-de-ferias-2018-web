Aula 01

https://nodejs.org/en/download/

https://angular.io/guide/quickstart

npm install -g @angular/cli

ng new euvim --style=scss 

ng serve

ng serve --open

https://material.angular.io/guide/getting-started

https://github.com/angular/material2

npm install --save @angular/material

npm install --save @angular/cdk

npm install --save @angular/animations

npm install --save hammerjs

code .

import { MaterialModule } from '@angular/material' (não é mais usado geral);

ModuleApp:
import {BrowserAnimationsModule} from '@angular/platform-browser/animations';

Index.html adicionar:
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

src/main.ts
import 'hammerjs';

styles.scss
@import "~@angular/material/prebuilt-themes/indigo-pink.css";

Aula 02

cd src/app/

https://github.com/angular/angular-cli

ng g module main
ng g component main

touch app.routing.ts

import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router';

@NgModule({
  imports: [
    RouterModule.forRoot([
      { path: '', redirectTo: '/main', pathMatch: 'full' }
    ], {useHash:true})
  ]
})
export class AppRoutingModule { }

touch main/main.routing.ts

import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router';

import { MainComponent } from './main.component';

@NgModule({
  imports: [
    RouterModule.forChild([
      { path: 'main', 
        component: MainComponent
      }
    ])
  ]
})
export class MainRouting { }

Importar em app.module.ts
import { RouterModule } from '@angular/router';
import { MainModule } from "./main/main.module";
import { AppRoutingModule } from "./app.routing";

Importar em main.module.ts
import { MainRouting } from './main.routing'; imports
import { RouterModule } from "@angular/router";imports
import { MainComponent } from './main.component'; [declarations]

Adicionar em app.component.html
<router-outlet></router-outlet>

Adicionar em main.component.html
<router-outlet></router-outlet>

Instal flex
npm install --save @angular/flex-layout

Import FlexLayoutModule em main
import { FlexLayoutModule } from "@angular/flex-layout";
import { MatIconModule, MatSidenavModule, MatCardModule, MatListModule, MatToolbarModule, MatButtonModule } from '@angular/material';
FlexLayoutModule,
MatIconModule,
MatSidenavModule,
MatCardModule,
MatListModule,
MatToolbarModule,
MatButtonModule

Adicionar no main.component.html
<mat-sidenav-container>
  <mat-sidenav #sidenav>
    <mat-nav-list>
      <mat-list-item>
        <button mat-icon-button >
            <mat-icon>info</mat-icon>
        </button>
        <a mdLine href="#/main">Usuários</a>
      </mat-list-item>
      <mat-list-item>
        <button mat-icon-button >
            <mat-icon>info</mat-icon>
        </button>
        <a mdLine href="#/main">Disciplinas</a>
      </mat-list-item>
      <mat-list-item>
        <button mat-icon-button >
            <mat-icon>info</mat-icon>
        </button>
        <a mdLine href="#/main">Relatório</a>
      </mat-list-item>
    </mat-nav-list>
  </mat-sidenav>
  <mat-toolbar color="primary">
    <span class="navSpan">
      <button mat-icon-button (click)="sidenav.open()">
          <mat-icon>menu</mat-icon>
      </button>
      <span>Eu vim</span>
      <button mat-icon-button (click)="sidenav.open()" class="user">
          <mat-icon>info</mat-icon>
      </button>
    </span>
  </mat-toolbar>
  <mat-card id="content">
    <router-outlet></router-outlet>
  </mat-card>
</mat-sidenav-container>

Adicionar em main.component.css
.navSpan {
    width: 100%;
}
button.user {
    float:right;
}
.mat-drawer-container{
    position: fixed;
    margin: 0px;
    height: 100%;
}
#content{
    position: fixed;
    left: 0px;
    right: 0px;
    bottom: 0px;
    top: 65px;
    z-index: -1;
    overflow-x: auto;
}

Aula 03

Ir até o site de components https://material.angular.io/components

dentro da pasta main/
ng g module usuario
cd usuario
ng g component consulta
ng g component formulario

Importar UsuarioModule em main.module.ts
import { UsuarioModule } from './usuario/usuario.module';

Adicionar no main.routing.ts

children: [
          {
            path: 'usuario/consulta',
            component: ConsultaComponent
          }
        ]

Alterar o menu main.component.html

de href="/main" para routerLink="/main/usuario/consulta"

Adicionar (click)="sidenav.close()"

Adicionar em usuário module a importação da table
import { MatTableModule, MatIconModule, MatButtonModule } from '@angular/material';

Adicionar em consulta.component.html
<div class="example-container mat-elevation-z8">
  <mat-table #table [dataSource]="dataSource">
    <ng-container matColumnDef="position">
      <mat-header-cell *matHeaderCellDef> No. </mat-header-cell>
      <mat-cell *matCellDef="let element"> {{element.position}} </mat-cell>
    </ng-container>
    <ng-container matColumnDef="name">
      <mat-header-cell *matHeaderCellDef> Name </mat-header-cell>
      <mat-cell *matCellDef="let element"> {{element.name}} </mat-cell>
    </ng-container>
    <ng-container matColumnDef="weight">
      <mat-header-cell *matHeaderCellDef> Weight </mat-header-cell>
      <mat-cell *matCellDef="let element"> {{element.weight}} </mat-cell>
    </ng-container>
    <ng-container matColumnDef="symbol">
      <mat-header-cell *matHeaderCellDef> Symbol </mat-header-cell>
      <mat-cell *matCellDef="let element"> {{element.symbol}} </mat-cell>
    </ng-container>
    <mat-header-row *matHeaderRowDef="displayedColumns"></mat-header-row>
    <mat-row *matRowDef="let row; columns: displayedColumns;"></mat-row>
  </mat-table>
</div>

Importar em consulta.component.ts
import { DataSource } from '@angular/cdk/collections';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/of';

Adicionar variaveis

public displayedColumns = ['position', 'name', 'weight', 'symbol'];
public dataSource = new UsuarioDataSource();

Adicionar interface e classes de dataSource

export interface Element {
  name: string;
  position: number;
  weight: number;
  symbol: string;
}

export class UsuarioDataSource extends DataSource<any> {
  /** Connect function called by the table to retrieve one stream containing the data to render. */
  connect(): Observable<Element[]> {
    return Observable.of([
      {position: 1, name: 'Hydrogen', weight: 1.0079, symbol: 'H'},
      {position: 2, name: 'Helium', weight: 4.0026, symbol: 'He'},
      {position: 3, name: 'Lithium', weight: 6.941, symbol: 'Li'},
      {position: 4, name: 'Beryllium', weight: 9.0122, symbol: 'Be'},
      {position: 5, name: 'Boron', weight: 10.811, symbol: 'B'},
      {position: 6, name: 'Carbon', weight: 12.0107, symbol: 'C'},
      {position: 7, name: 'Nitrogen', weight: 14.0067, symbol: 'N'},
      {position: 8, name: 'Oxygen', weight: 15.9994, symbol: 'O'},
      {position: 9, name: 'Fluorine', weight: 18.9984, symbol: 'F'},
      {position: 10, name: 'Neon', weight: 20.1797, symbol: 'Ne'},
      {position: 11, name: 'Sodium', weight: 22.9897, symbol: 'Na'},
      {position: 12, name: 'Magnesium', weight: 24.305, symbol: 'Mg'},
      {position: 13, name: 'Aluminum', weight: 26.9815, symbol: 'Al'},
      {position: 14, name: 'Silicon', weight: 28.0855, symbol: 'Si'},
      {position: 15, name: 'Phosphorus', weight: 30.9738, symbol: 'P'},
      {position: 16, name: 'Sulfur', weight: 32.065, symbol: 'S'},
      {position: 17, name: 'Chlorine', weight: 35.453, symbol: 'Cl'},
      {position: 18, name: 'Argon', weight: 39.948, symbol: 'Ar'},
      {position: 19, name: 'Potassium', weight: 39.0983, symbol: 'K'},
      {position: 20, name: 'Calcium', weight: 40.078, symbol: 'Ca'},
    ]);
  }

  disconnect() {}
}

Atualização dos dados, para corresponder as informações usuario
<div class="mat-elevation-z8">
  <mat-table #table [dataSource]="dataSource">
    <ng-container matColumnDef="position">
      <mat-header-cell *matHeaderCellDef  fxFlex="5"> Ações </mat-header-cell>
      <mat-cell *matCellDef="let element" fxFlex="5" class="buttons">
         <button mat-icon-button color="primary"  mdTooltip="Editar">
            <mat-icon class="mat-24" aria-label="Editar">edit</mat-icon>
          </button>
          <button mat-icon-button color="danger" mdTooltip="Remover">
              <mat-icon class="mat-24" aria-label="Remover">delete</mat-icon>
          </button>
      </mat-cell>
    </ng-container>
    <ng-container matColumnDef="nome">
      <mat-header-cell *matHeaderCellDef> Nome </mat-header-cell>
      <mat-cell *matCellDef="let element"> {{element.nome}} </mat-cell>
    </ng-container>
    <ng-container matColumnDef="login">
        <mat-header-cell *matHeaderCellDef> Login </mat-header-cell>
        <mat-cell *matCellDef="let element"> {{element.login}} </mat-cell>
    </ng-container>
    <ng-container matColumnDef="email">
      <mat-header-cell *matHeaderCellDef> E-mail </mat-header-cell>
      <mat-cell *matCellDef="let element"> {{element.email}} </mat-cell>
    </ng-container>
    <ng-container matColumnDef="perfil">
      <mat-header-cell *matHeaderCellDef> Perfil </mat-header-cell>
      <mat-cell *matCellDef="let element"> {{element.perfil}} </mat-cell>
    </ng-container>
    <mat-header-row *matHeaderRowDef="displayedColumns"></mat-header-row>
    <mat-row *matRowDef="let row; columns: displayedColumns;"></mat-row>
  </mat-table>
  <button mat-fab color="primary">
    <mat-icon class="mat-24" aria-label="Adicionar">add</mat-icon>
  </button> 
</div>

Inclusão do css para espaçamento do md-fab
.mat-fab{
    position: fixed;
    right: 20px;
    bottom: 20px;
}
   
No consulta.componente.ts atualizar os dados
public displayedColumns = ['position', 'nome', 'login', 'email', 'perfil'];
connect(): Observable<any[]> {
    return Observable.of([
      {position: 1, nome: 'José da Silva', login: "jose", email: 'jose@ponto.com.br', perfil:"Aluno"},
      {position: 2, nome: 'Mariano das Neves', login: "mariano", email: 'marino@ponto.com.br', perfil:"Aluno"},
      {position: 3, nome: 'Magyver da Silva', login: "magyver", email: 'magyver@ponto.com.br', perfil:"Aluno"},
      {position: 4, nome: 'Irineu Nunes', login: "irineu", email: 'irineu@ponto.com.br', perfil:"Aluno"},
      {position: 5, nome: 'Carlos Silva', login: "carlos", email: 'carlos@ponto.com.br', perfil:"Aluno"},
      {position: 5, nome: 'Carlos Silva', login: "carlos", email: 'carlos@ponto.com.br', perfil:"Aluno"},
      {position: 5, nome: 'Carlos Silva', login: "carlos", email: 'carlos@ponto.com.br', perfil:"Aluno"}
    ]);
  }


Aula 04

Adicionar no main.routing.ts
children: [
          {
            path: 'usuario/adicionar',
            component: FormularioComponent
          }
        ]

Adicionar importacao MainRouting em UsuarioModule;
import { MainRouting } from '../main.routing';

Incluir a rota no botão adicionar fab-button da listagem
routerLink="/main/usuario/adicionar"

Vamos criar um serviço que será responsável pelas request do usuario,
Dentro da pasta usuario 
ng g service usuario
vamos adicionar o seguinte código no Usuario.service.ts
  private listUsers = [
    {identifier: 1, nome: 'José da Silva', login: "jose", email: 'jose@ponto.com.br', perfil:"Aluno"},
    {identifier: 2, nome: 'Mariano das Neves', login: "mariano", email: 'marino@ponto.com.br', perfil:"Aluno"},
    {identifier: 3, nome: 'Magyver da Silva', login: "magyver", email: 'magyver@ponto.com.br', perfil:"Aluno"},
    {identifier: 4, nome: 'Irineu Nunes', login: "irineu", email: 'irineu@ponto.com.br', perfil:"Aluno"},
    {identifier: 5, nome: 'Carlos Silva', login: "carlos1", email: 'carlos@ponto.com.br', perfil:"Aluno"},
    {identifier: 6, nome: 'Carlos Silva', login: "carlos2", email: 'carlos@ponto.com.br', perfil:"Aluno"},
    {identifier: 7, nome: 'Carlos Silva', login: "carlos3", email: 'carlos@ponto.com.br', perfil:"Aluno"}
  ];
  adicionar(item){
    let maxIdentifier = 0;
    this.listUsers.forEach(item=>{
      maxIdentifier < item.identifier ? maxIdentifier = item.identifier : maxIdentifier = maxIdentifier;
    })
    item.identifier = maxIdentifier + 1;
    this.listUsers.push(item);
  }
  excluir(identifier){
    let index = this.listUsers.findIndex(item=> item.identifier == identifier);
    if(index > -1){
      this.listUsers.splice(index,1);
    }
  }
  editar(editItem){
    let index = this.listUsers.findIndex(item=> item.identifier == editItem.identifier);
    if(index > -1){
      this.listUsers[index] = editItem;
    }
  }
  listar(){
    return this.listUsers;
  }

No consulta.component.ts iremos remover, o mock pois agora estará no serviço, e iremos injetar o serviço:
 public displayedColumns = ['nome', 'login', 'email', 'perfil', 'identifier'];
 public dataSource;
 public noResults$ = false;
 constructor(private usuarioService:UsuarioService) { }
 ngOnInit() {
   this.getListUsers();
 }
 remover(identifer){
   this.usuarioService.excluir(identifer);
   this.getListUsers();
 }
 private getListUsers(){
   var items = this.usuarioService.listar();
   this.noResults$ = items.length == 0;
   this.dataSource = new MatTableDataSource(items);
 }

Agora no html iremos adicionar nos botões de editar e excluir a chamada das funções, e iremos incluir um no result para ficar mais amigável a tela:
<mat-icon class="md-24"  (click)="editar(element.identifier)" aria-label="Editar">edit</mat-icon>
<mat-icon class="md-24" (click)="remover(element.identifier)" aria-label="Remover">delete</mat-icon>
</mat-table>
  <div *ngIf="noResults$" class="noResult">Nenhum resultado</div>


Antes de criamos o formBUilder precisamos importálo no módulo, no campo de providers (UsuarioModule)
FormBuilder
E iremos adicionais os seguintes modulos (UsuarioModule):
ReactiveFormsModule,
FormsModule

Agora vamos injetar o serviço de usuário e criar um formBuilder, no formulario.component.ts que será responsável para inclusão do usuário.
form : FormGroup;
  constructor(private usuarioService:UsuarioService, fb:FormBuilder) {
    this.form = fb.group({
        nome : Validators.required,
        email: Validators.compose([Validators.required, Validators.email]),
        login: Validators.required,
        profile: Validators.required,
        senha: Validators.required,
        confirmacao: Validators.required
    })
   }
  
Porém no nosso formulário ele irá conter, uma listagem de perfils, para isto vamos por hora deixar um array:
  public profiles = [
    { value: "Professor", description: 'Professor' },
    { value: "Administrador", description: 'Administrador' },
    { value: "Aluno", description: 'Aluno' },
  ];

Depois disto podemos já criar nossa função de salvar, para utilizarmos o router, precisaremos injetar o mesmo:
constructor(private _usuarioService: UsuarioService,fb: FormBuilder, private _router: Router)
....
  salvar() {
    if(this.form.valid){
      this._usuarioService.adicionar(this.form.value);
      this.form.reset();
      this._router.navigate(['/main/usuario/consulta']);
    }
  }
....

Agora vamos adicionar o vinculo deste formulário ao HTML, para que possamos manipular os dados.
<form [formGroup]="form" fxLayout="column">
em, cada field iremos adicionaro o bind do campo e adicionar o required, para melhorar a interface
<input matInput formControlName="nome" placeholder="Nome">

e depois para cada campo do formulário iremos adicionar a linha abaixo para mensagem de erro
<mat-error *ngIf="form.controls['nome'].hasError('required')">
  Campo obrigatório
</mat-error>

e por fim no botão salvar vamos colocar o disabled caso o form seja inválido:
<button mat-raised-button color="primary"  [disabled]="!form.valid" (click)="salvar()">Cadastrar</button>

O html ficará desta forma:
<form [formGroup]="form" fxLayout="column">
  <mat-form-field fxFlex="100"> 
    <input matInput formControlName="nome" placeholder="Nome">
    <mat-error *ngIf="form.controls['nome'].hasError('required')">
      Campo obrigatório
    </mat-error>
  </mat-form-field>
  <mat-form-field fxFlex="100"> 
    <input matInput formControlName="email" placeholder="E-mail">
    <mat-error *ngIf="form.controls['email'].hasError('email') && !form.controls['email'].hasError('required')">
      E-mail inválido
    </mat-error>
    <mat-error *ngIf="form.controls['email'].hasError('required')">
      Campo obrigatório
    </mat-error>
  </mat-form-field>
  <div fxFlex="100" fxLayout="row">
    <mat-form-field fxFlex="47"> 
      <input matInput formControlName="login" placeholder="Login">
      <mat-error *ngIf="form.controls['login'].hasError('required')">
        Campo obrigatório
      </mat-error>
    </mat-form-field>
    <span fxFlex="5"></span>
    <mat-form-field fxFlex="47"> 
      <mat-select formControlName="profile" placeholder="Perfil">
          <mat-option *ngFor="let profile of profiles" [value]="profile.value">
            {{ profile.description }}
          </mat-option>
      </mat-select>
      <mat-error *ngIf="form.controls['profile'].hasError('required')">
        Campo obrigatório
      </mat-error>
    </mat-form-field>
  </div>
  <div fxFlex="100" fxLayout="row">
    <mat-form-field fxFlex="47"> 
      <input matInput formControlName="senha" placeholder="Senha" type="password">
      <mat-error *ngIf="form.controls['senha'].hasError('required')">
        Campo obrigatório
      </mat-error>
    </mat-form-field>
    <span fxFlex="5"></span>
    <mat-form-field fxFlex="47"> 
      <input matInput formControlName="confirmacao" placeholder="Confirmação" type="password">
      <mat-error *ngIf="form.controls['confirmacao'].hasError('required')">
        Campo obrigatório
      </mat-error>
    </mat-form-field>
  </div>
  <div fxFlex="100" fxLayout="row" fxLayoutAlign="space-between">
      <button mat-raised-button color="primary"  [disabled]="!form.valid" (click)="salvar()">Cadastrar</button>
      <button mat-raised-button color="warn" routerLink="/main/usuario/consulta">Cancelar</button>
  </div>
</form>


Porém nestas validações não tem a validação da confirmação de senha, podemos criar um validator para esta operação:
src/app/validators/equalPasswordsValidator.ts
import {FormGroup} from '@angular/forms';
export class EqualPasswordsValidator {
  public static validate(firstField, secondField) {
    return (c:FormGroup) => {       
    (c.controls && c.controls[firstField].value == c.controls[secondField].value) 
        ? c.controls[secondField].setErrors(c.controls[secondField].getError('required') ? {required: {valid:false}} : null) :
          c.controls[secondField].setErrors({passwordsEqual: {valid: false}});
    }
  }
}

E depois disto iremos informar, para o formGroup para que utilize a validação da senha, e quais campos serão:
this.form = fb.group({
      identifier: [null],
      nome: [null, Validators.required],
      email: [null, Validators.compose([Validators.required, Validators.email])],
      login: [null, Validators.required],
      perfil: [null, Validators.required],
      senha: [null, Validators.required],
      confirmacao: [null, Validators.required]
}, {validator: EqualPasswordsValidator.validate("senha","confirmacao")});


Aula 5
Vamos criar a edição utilizando do mesmo formulário, para isto vamos atualizar nosso router (main.routing.ts), incluiremos
{
  path: 'usuario/editar/:id',
  component: FormularioComponent
}

Vamos alterar/incluir o comportamento de edição no arquivo usuario/consulta/consulta.component.ts
Injetamos o Router do angular para que possamos redirecionar para o formulário e vamos criar a função editar:
constructor(private usuarioService:UsuarioService, private _router: Router) { }
editar(identifier){
    this._router.navigate(["/main/usuario/editar", identifier]);
  }



porém no nosso serviço ainda  não temos a consulta por ID, então iremos adicionar, no usuarioService.ts
getItem(identifier){
  return this.listUsers.find(item=> item.identifier == identifier);
}

Agora vamos fazer que na inicialização do formulário caso haja id, realizar a consulta dos dados:
para obter o parametro que iremos receber pela URL, precisamos do ActivatedRouter, para isso vamos injetalo.
constructor(private _usuarioService: UsuarioService, fb: FormBuilder, private _router: Router,private _activateRoute: ActivatedRoute)

Após isto iremos ajustar o init para que caso haja o parametro, realizemos a consulta dos dados, e setamos o componente como edição:
Variável para sabermos se estamos editando:
identifier = null;

Depois vamos atualizar o ngOnInit 
ngOnInit() {
  this.identifier = null;    
  this._activateRoute.params.subscribe(params=>{
    this.identifier = params['id'];
  })
  if(this.identifier){
    var item = <any> this._usuarioService.getItem(this.identifier);
    item.senha = null;
    item.confirmacao = null;
    this.form.setValue(item);
    this.form.get("senha").setValidators(null);
    this.form.get("confirmacao").setValidators(null);
  }
}

E vamos atualizar o método de salvar:
 salvar() {
  if(this.form.valid){
    if(this.identifier){
      this._usuarioService.editar(this.form.value);
    } else {
      this._usuarioService.adicionar(this.form.value);
    }
    this.form.reset();
    this._router.navigate(['/main/usuario/consulta']);
  }
}

Agora vamos mudar o nome do botão conforme a ação do formulário
<button mat-raised-button color="primary"  [disabled]="!form.valid" (click)="salvar()">{{ identifier ? 'Salvar' : 'Cadastrar'}}</button>


Vamos agora iniciar a inclusão do módulo http client, e end point para as chamadas do nosso mock.
- Primeiro vamos ajustar nossos envioroments para apontar para nosso end point.
  export const environment = {
    production: true,
    URL:"http://localhost:3000/api/v1/"
  };

Agora vamos no módulo de usuário incluir as dependencias necessárias para o HttpClient (usuario.module.ts)
import { HttpClientModule, HttpClient } from '@angular/common/http';
modules [
  HttpClientModule ...
]
providers [
  HttpClient ...
]

Agora iremos conectar nosso usuario.service.ts ao mock/servidor (usuario.service.ts)
constructor(private _httpClient:HttpClient ) { }

private _urlUser = environment.URL+"usuarios";

Vamos mudar inicialmente o comando de listagem (usuario.service.ts)
listar(){
  return this._httpClient.get<Array<Object>>(this._urlUser);
}
Agora precisamos ajustar (consulta.component.ts) para que realizar o subscribe
private getListUsers(){
  this.usuarioService.listar().subscribe(suc => {
      this.noResults$ = suc.length == 0;
      this.dataSource = new MatTableDataSource(suc);
    }
  );
}
Porém agora não é mais identifier e sim id temos que mudar no consulta.component.ts
public displayedColumns = ['nome', 'login', 'email', 'perfil', 'id'];
e no consulta.component.hmtl
<ng-container matColumnDef="id">
  <mat-header-cell *matHeaderCellDef  fxFlex="10"> Ações </mat-header-cell>
  <mat-cell *matCellDef="let element" fxFlex="10" class="buttons">
      <button mat-icon-button color="primary"  matTooltip="Editar">
        <mat-icon class="md-24"  (click)="editar(element.id)" aria-label="Editar">edit</mat-icon>
      </button>
      <button mat-icon-button color="danger" matTooltip="Remover">
          <mat-icon class="md-24" (click)="remover(element.id)" aria-label="Remover">delete</mat-icon>
      </button>
  </mat-cell>
</ng-container>

Vamos agora mudar o método de exclusão (usuario.service.ts)
excluir(identifier){
    return this._httpClient.delete(this._urlUser+"/"+identifier, {responseType: 'text'})
}
Agora precisamos ajustar (consulta.component.ts) para que realizar a exclusão
remover(identifer){
  this.usuarioService.excluir(identifer).subscribe(suc=>{
      this.getListUsers();
  });
}

Vamos realizar o ajuste de consulta especifica  (usuario.service.ts)
getItem(identifier){
  return this._httpClient.get(this._urlUser+"/"+identifier);
}

Agora vamos ajustar o formulário, quando é passado o ID para realizar a consulta, e ajustarmos o form (formulario.component.ts)
this.form = fb.group({
      id: [null],
      nome: [null, Validators.required],
      email: [null, Validators.compose([Validators.required, Validators.email])],
      login: [null, Validators.required],
      perfil: [null, Validators.required],
      senha: [null, Validators.required],
      confirmacao: [null, Validators.required],
      urlFoto: [null],
    }, {validator: EqualPasswordsValidator.validate("senha","confirmacao")})

ngOnInit() {
    this.identifier = null;    
    this._activateRoute.params.subscribe(params=>{
      this.identifier = params['id'];
    })
    if(this.identifier){
      this._usuarioService.getItem(this.identifier).subscribe(suc=>{
        var item = Object(suc);
        item.senha = null;
        item.confirmacao = null;
        this.form.setValue(item);
        this.form.get("senha").setValidators(null);
        this.form.get("confirmacao").setValidators(null);
      });
      
    }
  }

Vamos mudar agora o método de inclusão e edição (usuario.service.ts)
adicionar(item){
  return this._httpClient.post(this._urlUser, item, {responseType: 'text'});
}
editar(editItem){
  return this._httpClient.put(this._urlUser+"/"+editItem.id, editItem, {responseType: 'text'});
}
Agora vamos mudar o método de inclusão e edição para ter o subscribe, e ajustarmos os profiles.
public profiles = [
  { value: "PROFESSOR", description: 'Professor' },
  { value: "ADMINISTRADOR", description: 'Administrador' },
  { value: "ALUNO", description: 'Aluno' },
];
salvar() {
  if(this.form.valid){
    if(this.identifier){
      this._usuarioService.editar(this.form.value).subscribe(suc=>{
        this.form.reset();
        this._router.navigate(['/main/usuario/consulta']);
      })
    } else {
      this._usuarioService.adicionar(this.form.value).subscribe(suc=>{
          this.form.reset();
          this._router.navigate(['/main/usuario/consulta']);
        }
      )
    }
  }
}

Agora sim nosso crud está conectado ao servidor/mock.

