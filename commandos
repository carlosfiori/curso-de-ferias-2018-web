Aula 02

cd src/app/

https://github.com/angular/angular-cli

ng g module main
ng g component main

touch app.routing.ts

import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router';

@NgModule({
  imports: [
    RouterModule.forRoot([
      { path: '', redirectTo: '/main', pathMatch: 'full' }
    ], {useHash:true})
  ]
})
export class AppRoutingModule { }

touch main/main.routing.ts

import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router';

import { MainComponent } from './main.component';

@NgModule({
  imports: [
    RouterModule.forChild([
      { path: 'main', 
        component: MainComponent
      }
    ])
  ]
})
export class MainRouting { }

Importar em app.module.ts
import { RouterModule } from '@angular/router';
import { MainModule } from "./main/main.module";
import { AppRoutingModule } from "./app.routing";

Importar em main.module.ts
import { MainRouting } from './main.routing'; imports
import { RouterModule } from "@angular/router";imports
import { MainComponent } from './main.component'; [declarations]

Adicionar em app.component.html
<router-outlet></router-outlet>

Adicionar em main.component.html
<router-outlet></router-outlet>

Instal flex
npm install --save @angular/flex-layout

Import FlexLayoutModule em main
import { FlexLayoutModule } from "@angular/flex-layout";
import { MatIconModule, MatSidenavModule, MatCardModule, MatListModule, MatToolbarModule, MatButtonModule } from '@angular/material';
FlexLayoutModule,
MatIconModule,
MatSidenavModule,
MatCardModule,
MatListModule,
MatToolbarModule,
MatButtonModule

Adicionar no main.component.html
<mat-sidenav-container>
  <mat-sidenav #sidenav>
  <a mat-button style="height: 0; position: absolute;"> <!-- 'absorbs' the behavior --></a>  
    <mat-nav-list>
      <mat-list-item href="#/main">
        <button mat-icon-button >
            <mat-icon>info</mat-icon>
        </button>
        <a mdLine>Usuários</a>
      </mat-list-item>
      <mat-list-item href="#/main">
        <button mat-icon-button >
            <mat-icon>info</mat-icon>
        </button>
        <a mdLine>Disciplinas</a>
      </mat-list-item>
      <mat-list-item href="#/main">
        <button mat-icon-button >
            <mat-icon>info</mat-icon>
        </button>
        <a mdLine>Relatório</a>
      </mat-list-item>
    </mat-nav-list>
  </mat-sidenav>
  <mat-toolbar color="primary">
      <button mat-icon-button (click)="sidenav.open()">
          <mat-icon>menu</mat-icon>
      </button>
      <span>Eu vim</span>
  </mat-toolbar>
  <mat-card id="content">
    <router-outlet></router-outlet>
  </mat-card>
</mat-sidenav-container>

Adicionar em main.component.css
.navSpan {
    width: 100%;
}
button.user {
    float:right;
}
.mat-drawer-container{
    position: fixed;
    margin: 0px;
    height: 100%;
}
#content{
    position: fixed;
    left: 0px;
    right: 0px;
    bottom: 0px;
    top: 65px;
    z-index: -1;
    overflow-x: auto;
}

Aula 03

Ir até o site de components https://material.angular.io/components

dentro da pasta main/
ng g module usuario
cd usuario
ng g component consulta
ng g component formulario

Importar UsuarioModule em main.module.ts
import { UsuarioModule } from './usuario/usuario.module';

Adicionar no main.routing.ts

children: [
          {
            path: 'usuario/consulta',
            component: ConsultaComponent
          }
        ]

Alterar o menu main.component.html

de href="/main" para routerLink="/main/usuario/consulta"

Adicionar (click)="sidenav.close()"

Adicionar em usuário module a importação da table
import { MatTableModule, MatIconModule, MatButtonModule } from '@angular/material';

Adicionar em consulta.component.html
<div class="example-container mat-elevation-z8">
  <mat-table #table [dataSource]="dataSource">
    <ng-container matColumnDef="position">
      <mat-header-cell *matHeaderCellDef> No. </mat-header-cell>
      <mat-cell *matCellDef="let element"> {{element.position}} </mat-cell>
    </ng-container>
    <ng-container matColumnDef="name">
      <mat-header-cell *matHeaderCellDef> Name </mat-header-cell>
      <mat-cell *matCellDef="let element"> {{element.name}} </mat-cell>
    </ng-container>
    <ng-container matColumnDef="weight">
      <mat-header-cell *matHeaderCellDef> Weight </mat-header-cell>
      <mat-cell *matCellDef="let element"> {{element.weight}} </mat-cell>
    </ng-container>
    <ng-container matColumnDef="symbol">
      <mat-header-cell *matHeaderCellDef> Symbol </mat-header-cell>
      <mat-cell *matCellDef="let element"> {{element.symbol}} </mat-cell>
    </ng-container>
    <mat-header-row *matHeaderRowDef="displayedColumns"></mat-header-row>
    <mat-row *matRowDef="let row; columns: displayedColumns;"></mat-row>
  </mat-table>
</div>

Importar em consulta.component.ts
import { DataSource } from '@angular/cdk/collections';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/of';

Adicionar variaveis

public displayedColumns = ['position', 'name', 'weight', 'symbol'];
public dataSource = new UsuarioDataSource();

Adicionar interface e classes de dataSource

export interface Element {
  name: string;
  position: number;
  weight: number;
  symbol: string;
}

export class UsuarioDataSource extends DataSource<any> {
  /** Connect function called by the table to retrieve one stream containing the data to render. */
  connect(): Observable<Element[]> {
    return Observable.of([
      {position: 1, name: 'Hydrogen', weight: 1.0079, symbol: 'H'},
      {position: 2, name: 'Helium', weight: 4.0026, symbol: 'He'},
      {position: 3, name: 'Lithium', weight: 6.941, symbol: 'Li'},
      {position: 4, name: 'Beryllium', weight: 9.0122, symbol: 'Be'},
      {position: 5, name: 'Boron', weight: 10.811, symbol: 'B'},
      {position: 6, name: 'Carbon', weight: 12.0107, symbol: 'C'},
      {position: 7, name: 'Nitrogen', weight: 14.0067, symbol: 'N'},
      {position: 8, name: 'Oxygen', weight: 15.9994, symbol: 'O'},
      {position: 9, name: 'Fluorine', weight: 18.9984, symbol: 'F'},
      {position: 10, name: 'Neon', weight: 20.1797, symbol: 'Ne'},
      {position: 11, name: 'Sodium', weight: 22.9897, symbol: 'Na'},
      {position: 12, name: 'Magnesium', weight: 24.305, symbol: 'Mg'},
      {position: 13, name: 'Aluminum', weight: 26.9815, symbol: 'Al'},
      {position: 14, name: 'Silicon', weight: 28.0855, symbol: 'Si'},
      {position: 15, name: 'Phosphorus', weight: 30.9738, symbol: 'P'},
      {position: 16, name: 'Sulfur', weight: 32.065, symbol: 'S'},
      {position: 17, name: 'Chlorine', weight: 35.453, symbol: 'Cl'},
      {position: 18, name: 'Argon', weight: 39.948, symbol: 'Ar'},
      {position: 19, name: 'Potassium', weight: 39.0983, symbol: 'K'},
      {position: 20, name: 'Calcium', weight: 40.078, symbol: 'Ca'},
    ]);
  }

  disconnect() {}
}

Atualização dos dados, para corresponder as informações usuario
<div class="mat-elevation-z8">
  <mat-table #table [dataSource]="dataSource">
    <ng-container matColumnDef="position">
      <mat-header-cell *matHeaderCellDef  fxFlex="5"> Ações </mat-header-cell>
      <mat-cell *matCellDef="let element" fxFlex="5" class="buttons">
         <button mat-icon-button color="primary"  mdTooltip="Editar">
            <mat-icon class="mat-24" aria-label="Editar">edit</mat-icon>
          </button>
          <button mat-icon-button color="danger" mdTooltip="Remover">
              <mat-icon class="mat-24" aria-label="Remover">delete</mat-icon>
          </button>
      </mat-cell>
    </ng-container>
    <ng-container matColumnDef="nome">
      <mat-header-cell *matHeaderCellDef> Nome </mat-header-cell>
      <mat-cell *matCellDef="let element"> {{element.nome}} </mat-cell>
    </ng-container>
    <ng-container matColumnDef="login">
        <mat-header-cell *matHeaderCellDef> Login </mat-header-cell>
        <mat-cell *matCellDef="let element"> {{element.login}} </mat-cell>
    </ng-container>
    <ng-container matColumnDef="email">
      <mat-header-cell *matHeaderCellDef> E-mail </mat-header-cell>
      <mat-cell *matCellDef="let element"> {{element.email}} </mat-cell>
    </ng-container>
    <ng-container matColumnDef="perfil">
      <mat-header-cell *matHeaderCellDef> Perfil </mat-header-cell>
      <mat-cell *matCellDef="let element"> {{element.perfil}} </mat-cell>
    </ng-container>
    <mat-header-row *matHeaderRowDef="displayedColumns"></mat-header-row>
    <mat-row *matRowDef="let row; columns: displayedColumns;"></mat-row>
  </mat-table>
  <button mat-fab color="primary">
    <mat-icon class="mat-24" aria-label="Adicionar">add</mat-icon>
  </button> 
</div>

Inclusão do css para espaçamento do md-fab
.mat-fab{
    position: fixed;
    right: 20px;
    bottom: 20px;
}
   
No consulta.componente.ts atualizar os dados
public displayedColumns = ['position', 'nome', 'login', 'email', 'perfil'];
connect(): Observable<any[]> {
    return Observable.of([
      {position: 1, nome: 'José da Silva', login: "jose", email: 'jose@ponto.com.br', perfil:"Aluno"},
      {position: 2, nome: 'Mariano das Neves', login: "mariano", email: 'marino@ponto.com.br', perfil:"Aluno"},
      {position: 3, nome: 'Magyver da Silva', login: "magyver", email: 'magyver@ponto.com.br', perfil:"Aluno"},
      {position: 4, nome: 'Irineu Nunes', login: "irineu", email: 'irineu@ponto.com.br', perfil:"Aluno"},
      {position: 5, nome: 'Carlos Silva', login: "carlos", email: 'carlos@ponto.com.br', perfil:"Aluno"},
      {position: 5, nome: 'Carlos Silva', login: "carlos", email: 'carlos@ponto.com.br', perfil:"Aluno"},
      {position: 5, nome: 'Carlos Silva', login: "carlos", email: 'carlos@ponto.com.br', perfil:"Aluno"}
    ]);
  }


Aula 04

Adicionar no main.routing.ts
children: [
          {
            path: 'usuario/adicionar',
            component: FormularioComponent
          }
        ]

Adicionar importacao MainRouting em UsuarioModule;
import { MainRouting } from '../main.routing';

Incluir a rota no botão adicionar fab-button da listagem
routerLink="/main/usuario/adicionar"

Vamos criar um serviço que será responsável pelas request do usuario,
Dentro da pasta usuario 
ng g service usuario
vamos adicionar o seguinte código no Usuario.service.ts
  private listUsers = [
    {identifier: 1, nome: 'José da Silva', login: "jose", email: 'jose@ponto.com.br', perfil:"Aluno"},
    {identifier: 2, nome: 'Mariano das Neves', login: "mariano", email: 'marino@ponto.com.br', perfil:"Aluno"},
    {identifier: 3, nome: 'Magyver da Silva', login: "magyver", email: 'magyver@ponto.com.br', perfil:"Aluno"},
    {identifier: 4, nome: 'Irineu Nunes', login: "irineu", email: 'irineu@ponto.com.br', perfil:"Aluno"},
    {identifier: 5, nome: 'Carlos Silva', login: "carlos1", email: 'carlos@ponto.com.br', perfil:"Aluno"},
    {identifier: 6, nome: 'Carlos Silva', login: "carlos2", email: 'carlos@ponto.com.br', perfil:"Aluno"},
    {identifier: 7, nome: 'Carlos Silva', login: "carlos3", email: 'carlos@ponto.com.br', perfil:"Aluno"}
  ];
  adicionar(item){
    let maxIdentifier = 0;
    this.listUsers.forEach(item=>{
      maxIdentifier < item.identifier ? maxIdentifier = item.identifier : maxIdentifier = maxIdentifier;
    })
    item.identifier = maxIdentifier + 1;
    this.listUsers.push(item);
  }
  excluir(identifier){
    let index = this.listUsers.findIndex(item=> item.identifier == identifier);
    if(index > -1){
      this.listUsers.splice(index,1);
    }
  }
  editar(editItem){
    let index = this.listUsers.findIndex(item=> item.identifier == editItem.identifier);
    if(index > -1){
      this.listUsers[index] = editItem;
    }
  }
  listar(){
    return this.listUsers;
  }

No consulta.component.ts iremos remover, o mock pois agora estará no serviço, e iremos injetar o serviço:
 public displayedColumns = ['nome', 'login', 'email', 'perfil', 'identifier'];
 public dataSource;
 public noResults$ = false;
 constructor(private usuarioService:UsuarioService) { }
 ngOnInit() {
   this.getListUsers();
 }
 remover(identifer){
   this.usuarioService.excluir(identifer);
   this.getListUsers();
 }
 private getListUsers(){
   var items = this.usuarioService.listar();
   this.noResults$ = items.length == 0;
   this.dataSource = new MatTableDataSource(items);
 }

Agora no html iremos adicionar nos botões de editar e excluir a chamada das funções, e iremos incluir um no result para ficar mais amigável a tela:
<mat-icon class="md-24"  (click)="editar(element.identifier)" aria-label="Editar">edit</mat-icon>
<mat-icon class="md-24" (click)="remover(element.identifier)" aria-label="Remover">delete</mat-icon>
</mat-table>
  <div *ngIf="noResults$" class="noResult">Nenhum resultado</div>


Antes de criamos o formBUilder precisamos importálo no módulo, no campo de providers (UsuarioModule)
FormBuilder
E iremos adicionais os seguintes modulos (UsuarioModule):
ReactiveFormsModule,
FormsModule

Agora vamos injetar o serviço de usuário e criar um formBuilder, no formulario.component.ts que será responsável para inclusão do usuário.
form : FormGroup;
  constructor(private usuarioService:UsuarioService, fb:FormBuilder) {
    this.form = fb.group({
        nome : Validators.required,
        email: Validators.compose([Validators.required, Validators.email]),
        login: Validators.required,
        profile: Validators.required,
        senha: Validators.required,
        confirmacao: Validators.required
    })
   }
  
Porém no nosso formulário ele irá conter, uma listagem de perfils, para isto vamos por hora deixar um array:
  public profiles = [
    { value: "Professor", description: 'Professor' },
    { value: "Administrador", description: 'Administrador' },
    { value: "Aluno", description: 'Aluno' },
  ];

Depois disto podemos já criar nossa função de salvar, para utilizarmos o router, precisaremos injetar o mesmo:
constructor(private _usuarioService: UsuarioService,fb: FormBuilder, private _router: Router)
....
  salvar() {
    if(this.form.valid){
      this._usuarioService.adicionar(this.form.value);
      this.form.reset();
      this._router.navigate(['/main/usuario/consulta']);
    }
  }
....

Agora vamos adicionar o vinculo deste formulário ao HTML, para que possamos manipular os dados.
<form [formGroup]="form" fxLayout="column">
em, cada field iremos adicionaro o bind do campo e adicionar o required, para melhorar a interface
<input matInput formControlName="nome" placeholder="Nome">

e depois para cada campo do formulário iremos adicionar a linha abaixo para mensagem de erro
<mat-error *ngIf="form.controls['nome'].hasError('required')">
  Campo obrigatório
</mat-error>

e por fim no botão salvar vamos colocar o disabled caso o form seja inválido:
<button mat-raised-button color="primary"  [disabled]="!form.valid" (click)="salvar()">Cadastrar</button>

O html ficará desta forma:
<form [formGroup]="form" fxLayout="column">
  <mat-form-field fxFlex="100"> 
    <input matInput formControlName="nome" placeholder="Nome">
    <mat-error *ngIf="form.controls['nome'].hasError('required')">
      Campo obrigatório
    </mat-error>
  </mat-form-field>
  <mat-form-field fxFlex="100"> 
    <input matInput formControlName="email" placeholder="E-mail">
    <mat-error *ngIf="form.controls['email'].hasError('email') && !form.controls['email'].hasError('required')">
      E-mail inválido
    </mat-error>
    <mat-error *ngIf="form.controls['email'].hasError('required')">
      Campo obrigatório
    </mat-error>
  </mat-form-field>
  <div fxFlex="100" fxLayout="row">
    <mat-form-field fxFlex="47"> 
      <input matInput formControlName="login" placeholder="Login">
      <mat-error *ngIf="form.controls['login'].hasError('required')">
        Campo obrigatório
      </mat-error>
    </mat-form-field>
    <span fxFlex="5"></span>
    <mat-form-field fxFlex="47"> 
      <mat-select formControlName="profile" placeholder="Perfil">
          <mat-option *ngFor="let profile of profiles" [value]="profile.value">
            {{ profile.description }}
          </mat-option>
      </mat-select>
      <mat-error *ngIf="form.controls['profile'].hasError('required')">
        Campo obrigatório
      </mat-error>
    </mat-form-field>
  </div>
  <div fxFlex="100" fxLayout="row">
    <mat-form-field fxFlex="47"> 
      <input matInput formControlName="senha" placeholder="Senha" type="password">
      <mat-error *ngIf="form.controls['senha'].hasError('required')">
        Campo obrigatório
      </mat-error>
    </mat-form-field>
    <span fxFlex="5"></span>
    <mat-form-field fxFlex="47"> 
      <input matInput formControlName="confirmacao" placeholder="Confirmação" type="password">
      <mat-error *ngIf="form.controls['confirmacao'].hasError('required')">
        Campo obrigatório
      </mat-error>
    </mat-form-field>
  </div>
  <div fxFlex="100" fxLayout="row" fxLayoutAlign="space-between">
      <button mat-raised-button color="primary"  [disabled]="!form.valid" (click)="salvar()">Cadastrar</button>
      <button mat-raised-button color="warn" routerLink="/main/usuario/consulta">Cancelar</button>
  </div>
</form>


Porém nestas validações não tem a validação da confirmação de senha, podemos criar um validator para esta operação:
src/app/validators/equalPasswordsValidator.ts
import {FormGroup} from '@angular/forms';
export class EqualPasswordsValidator {
  public static validate(firstField, secondField) {
    return (c:FormGroup) => {       
    (c.controls && c.controls[firstField].value == c.controls[secondField].value) 
        ? c.controls[secondField].setErrors(c.controls[secondField].getError('required') ? {required: {valid:false}} : null) :
          c.controls[secondField].setErrors({passwordsEqual: {valid: false}});
    }
  }
}

E depois disto iremos informar, para o formGroup para que utilize a validação da senha, e quais campos serão:
this.form = fb.group({
      identifier: [null],
      nome: [null, Validators.required],
      email: [null, Validators.compose([Validators.required, Validators.email])],
      login: [null, Validators.required],
      perfil: [null, Validators.required],
      senha: [null, Validators.required],
      confirmacao: [null, Validators.required]
}, {validator: EqualPasswordsValidator.validate("senha","confirmacao")});


Aula 5
Vamos criar a edição utilizando do mesmo formulário, para isto vamos atualizar nosso router (main.routing.ts), incluiremos
{
  path: 'usuario/editar/:id',
  component: FormularioComponent
}

Vamos alterar/incluir o comportamento de edição no arquivo usuario/consulta/consulta.component.ts
Injetamos o Router do angular para que possamos redirecionar para o formulário e vamos criar a função editar:
constructor(private usuarioService:UsuarioService, private _router: Router) { }
editar(identifier){
    this._router.navigate(["/main/usuario/editar", identifier]);
  }



porém no nosso serviço ainda  não temos a consulta por ID, então iremos adicionar, no usuarioService.ts
getItem(identifier){
  return this.listUsers.find(item=> item.identifier == identifier);
}

Agora vamos fazer que na inicialização do formulário caso haja id, realizar a consulta dos dados:
para obter o parametro que iremos receber pela URL, precisamos do ActivatedRouter, para isso vamos injetalo.
constructor(private _usuarioService: UsuarioService, fb: FormBuilder, private _router: Router,private _activateRoute: ActivatedRoute)

Após isto iremos ajustar o init para que caso haja o parametro, realizemos a consulta dos dados, e setamos o componente como edição:
Variável para sabermos se estamos editando:
identifier = null;

Depois vamos atualizar o ngOnInit 
ngOnInit() {
  this.identifier = null;    
  this._activateRoute.params.subscribe(params=>{
    this.identifier = params['id'];
  })
  if(this.identifier){
    var item = <any> this._usuarioService.getItem(this.identifier);
    item.senha = null;
    item.confirmacao = null;
    this.form.setValue(item);
    this.form.get("senha").setValidators(null);
    this.form.get("confirmacao").setValidators(null);
  }
}

E vamos atualizar o método de salvar:
 salvar() {
  if(this.form.valid){
    if(this.identifier){
      this._usuarioService.editar(this.form.value);
    } else {
      this._usuarioService.adicionar(this.form.value);
    }
    this.form.reset();
    this._router.navigate(['/main/usuario/consulta']);
  }
}

Agora vamos mudar o nome do botão conforme a ação do formulário
<button mat-raised-button color="primary"  [disabled]="!form.valid" (click)="salvar()">{{ identifier ? 'Salvar' : 'Cadastrar'}}</button>


Vamos agora iniciar a inclusão do módulo http client, e end point para as chamadas do nosso mock.
- Primeiro vamos ajustar nossos envioroments para apontar para nosso end point.
  export const environment = {
    production: true,
    URL:"http://localhost:3000/api/v1/"
  };

Agora vamos no módulo de usuário incluir as dependencias necessárias para o HttpClient (usuario.module.ts)
import { HttpClientModule, HttpClient } from '@angular/common/http';
modules [
  HttpClientModule ...
]
providers [
  HttpClient ...
]

Agora iremos conectar nosso usuario.service.ts ao mock/servidor (usuario.service.ts)
constructor(private _httpClient:HttpClient ) { }

private _urlUser = environment.URL+"usuarios";

Vamos mudar inicialmente o comando de listagem (usuario.service.ts)
listar(){
  return this._httpClient.get<Array<Object>>(this._urlUser);
}
Agora precisamos ajustar (consulta.component.ts) para que realizar o subscribe
private getListUsers(){
  this.usuarioService.listar().subscribe(suc => {
      this.noResults$ = suc.length == 0;
      this.dataSource = new MatTableDataSource(suc);
    }
  );
}
Porém agora não é mais identifier e sim id temos que mudar no consulta.component.ts
public displayedColumns = ['nome', 'login', 'email', 'perfil', 'id'];
e no consulta.component.hmtl
<ng-container matColumnDef="id">
  <mat-header-cell *matHeaderCellDef  fxFlex="10"> Ações </mat-header-cell>
  <mat-cell *matCellDef="let element" fxFlex="10" class="buttons">
      <button mat-icon-button color="primary"  matTooltip="Editar">
        <mat-icon class="md-24"  (click)="editar(element.id)" aria-label="Editar">edit</mat-icon>
      </button>
      <button mat-icon-button color="danger" matTooltip="Remover">
          <mat-icon class="md-24" (click)="remover(element.id)" aria-label="Remover">delete</mat-icon>
      </button>
  </mat-cell>
</ng-container>

Vamos agora mudar o método de exclusão (usuario.service.ts)
excluir(identifier){
    return this._httpClient.delete(this._urlUser+"/"+identifier, {responseType: 'text'})
}
Agora precisamos ajustar (consulta.component.ts) para que realizar a exclusão
remover(identifer){
  this.usuarioService.excluir(identifer).subscribe(suc=>{
      this.getListUsers();
  });
}

Vamos realizar o ajuste de consulta especifica  (usuario.service.ts)
getItem(identifier){
  return this._httpClient.get(this._urlUser+"/"+identifier);
}

Agora vamos ajustar o formulário, quando é passado o ID para realizar a consulta, e ajustarmos o form (formulario.component.ts)
this.form = fb.group({
      id: [null],
      nome: [null, Validators.required],
      email: [null, Validators.compose([Validators.required, Validators.email])],
      login: [null, Validators.required],
      perfil: [null, Validators.required],
      senha: [null, Validators.required],
      confirmacao: [null, Validators.required]
    }, {validator: EqualPasswordsValidator.validate("senha","confirmacao")})

ngOnInit() {
    this.identifier = null;    
    this._activateRoute.params.subscribe(params=>{
      this.identifier = params['id'];
    })
    if(this.identifier){
      this._usuarioService.getItem(this.identifier).subscribe(suc=>{
        var item = Object(suc);
        delete item.urlFoto;
        item.senha = null;
        item.confirmacao = null;
        this.form.get("senha").setValidators(null);
        this.form.get("confirmacao").setValidators(null);
        this.form.setValue(item);
      });
      
    }
  }

Vamos mudar agora o método de inclusão e edição (usuario.service.ts)
adicionar(item){
  return this._httpClient.post(this._urlUser, item, {responseType: 'text'});
}
editar(editItem){
  return this._httpClient.put(this._urlUser+"/"+editItem.id, editItem, {responseType: 'text'});
}
Agora vamos mudar o método de inclusão e edição para ter o subscribe, e ajustarmos os profiles.
public profiles = [
  { value: "PROFESSOR", description: 'Professor' },
  { value: "ADMINISTRADOR", description: 'Administrador' },
  { value: "ALUNO", description: 'Aluno' },
];
salvar() {
  if(this.form.valid){
    if(this.identifier){
      this._usuarioService.editar(this.form.value).subscribe(suc=>{
        this.form.reset();
        this._router.navigate(['/main/usuario/consulta']);
      })
    } else {
      this._usuarioService.adicionar(this.form.value).subscribe(suc=>{
          this.form.reset();
          this._router.navigate(['/main/usuario/consulta']);
        }
      )
    }
  }
}

Agora sim nosso crud está conectado ao servidor/mock e com isso não precisamos mais do array de usuarios do arquivo usuario.service.ts
podemos remover o array: listUsers 

Aula 06
Agora precisamos replicar todo esse comportamento, para disciplinas, porém nossas rotas ainda não estão muito amigáveis
ou seja, nossa rota está sendo definida ao componente importado, e não ao módulo, vamos ajustar isto?
Para isto vamos criar uma arquivo de rotas no nosso módulo, como não utilizamos na criação --routing vamos criar na mão.
Na pasta usuario vamos criar o arquivo abaixo com nome usuario.routing.ts: 

import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router';

import { ConsultaComponent } from './consulta/consulta.component';
import { FormularioComponent } from './formulario/formulario.component';

@NgModule({
  imports: [
    RouterModule.forChild([
      {
        path: 'consulta',
        component: ConsultaComponent
      },
      {
        path: 'adicionar',
        component: FormularioComponent
      },
      {
        path: 'editar/:id',
        component: FormularioComponent
      }
    ])
  ]
})
export class UsuarioRouting { }

Após isto iremos importar no "usuario.module.ts" esse mapeamento
import { UsuarioRouting } from './usuario.routing';

imports: [
    ...
    UsuarioRouting,
    RouterModule,
    ...
],

Agora vamos mudar nossa main.routing.ts pois o mapeamento do usuário está no módulo e não mais nela.
@NgModule({
  imports: [
    RouterModule.forChild([
      { path: 'main', 
        component: MainComponent,
        children: [
          {
            path: 'usuario',
            loadChildren: './usuario/usuario.module#UsuarioModule'
          }
        ]
      }
    ])
  ]
})
export class MainRouting { }

E olha que legal usando módulos com rotas, não precisamos mais carregar o módulo usuário, no "main.module.ts" assim fazemos um lazyLoad nos módulos
@NgModule({
  imports: [
    CommonModule,
    MainRouting,
    RouterModule,
    FlexLayoutModule,
    MatIconModule,
    MatSidenavModule,
    MatCardModule,
    MatListModule,
    MatToolbarModule,
    MatButtonModule
  ],
  declarations: [MainComponent]
})
export class MainModule { }

Agora que temos um módulo isolado do usuário, podemos replicálo para as disciplinas, então para termos um ganho de tempo 
vamos Copiar a pasta usuário e colar a mesma como disciplinas.
Vamos renomear todos nossos ts de usuario -> disciplinas
usuario.module.ts -> disciplina.module.ts (Lembrese mudar internamente o nome da classe também)
usuario.routing.ts -> disciplina.routing.ts (Lembrese mudar internamente o nome da classe também)
usuario.service.spec.ts -> disciplina.service.spec.ts (Lembrese mudar internamente o nome da classe também)
usuario.service.ts -> disciplina.service.ts (Lembrese mudar internamente o nome da classe também)

Então nossos arquivos terão os seguintes conteúdos:
- disciplina.module.ts
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ConsultaComponent } from './consulta/consulta.component';
import { FormularioComponent } from './formulario/formulario.component';
import { MatTableModule, MatIconModule, MatButtonModule, MatFormFieldModule, MatInputModule, MatTooltipModule, MatSelectModule, MatOptionModule } from '@angular/material';
import { RouterModule } from '@angular/router';
import { FlexLayoutModule } from '@angular/flex-layout';
import { DisciplinaService } from './disciplina.service';
import { DisciplinaRouting } from './disciplina.routing';
import { FormBuilder, ReactiveFormsModule, FormsModule } from '@angular/forms';
import { HttpClientModule, HttpClient } from '@angular/common/http';

@NgModule({
  imports: [
    CommonModule,
    MatTableModule,
    MatIconModule,
    MatButtonModule,
    DisciplinaRouting,
    RouterModule,
    MatFormFieldModule,
    MatInputModule,
    FlexLayoutModule,
    MatTooltipModule,
    MatSelectModule, 
    MatOptionModule,
    ReactiveFormsModule,
    FormsModule,
    HttpClientModule
  ],
  declarations: [ConsultaComponent, FormularioComponent],
  providers: [HttpClient,DisciplinaService, FormBuilder]
})
export class DisciplinaModule { }

-disciplina.routing.ts
import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router';

import { ConsultaComponent } from './consulta/consulta.component';
import { FormularioComponent } from './formulario/formulario.component';

@NgModule({
  imports: [
    RouterModule.forChild([
      {
        path: 'consulta',
        component: ConsultaComponent
      },
      {
        path: 'adicionar',
        component: FormularioComponent
      },
      {
        path: 'editar/:id',
        component: FormularioComponent
      }
    ])
  ]
})
export class DisciplinaRouting { }

- disciplina.service.spec.ts
import { TestBed, inject } from '@angular/core/testing';

import { DisciplinaService } from './disciplina.service';

describe('DisciplinaService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [DisciplinaService]
    });
  });

  it('should be created', inject([DisciplinaService], (service: DisciplinaService) => {
    expect(service).toBeTruthy();
  }));
});

- disciplina.service.ts
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { environment } from '../../../environments/environment';
import { Observable } from 'rxjs/Observable';

@Injectable()
export class DisciplinaService {

  constructor(private _httpClient:HttpClient ) { }

  private _urlDisciplina = environment.URL+"disciplinas";

  adicionar(item){
    return this._httpClient.post(this._urlDisciplina, item, {responseType: 'text'});
  }

  excluir(identifier){
    return this._httpClient.delete(this._urlDisciplina+"/"+identifier, {responseType: 'text'})
  }

  editar(editItem){
    return this._httpClient.put(this._urlDisciplina+"/"+editItem.id, editItem, {responseType: 'text'});
  }

  getItem(identifier){
    return this._httpClient.get<any>(this._urlDisciplina+"/"+identifier);
  }

  listar(){
    return this._httpClient.get<Array<Object>>(this._urlDisciplina);
  }
}

Primeiramente vamos ajustar o "disciplina/consulta.component.ts" para que chame o novo serviço, para listagem de disciplinas, e vamos ajustar os campos da tabela.
Vamos mudar a importação
 - import { UsuarioService } from '../usuario.service'; -> import { DisciplinaService } from '../disciplina.service';
após isto vamos renomear a injeção do serviço e renomear todas as chamadas.
 - constructor(private _disciplinaService:DisciplinaService, private _router: Router) { }
Agora vamos mudar o redirecionamento caso clicar para edição de uma disciplina:
 - this._router.navigate(["/main/usuario/editar", identifier]); -> this._router.navigate(["/main/disciplina/editar", identifier]);
Vamos ajustar as colunas que teremos em nosso HTML, conforme swagger
public displayedColumns = ['nome', 'login', 'email', 'perfil', 'id']; -> public displayedColumns = ['segmento', 'descricao', 'dataInicio', 'dataTermino','instrutores', 'id'];
Agora vamos ajustar a table para mostrar as informações que iremos receber em "disciplina/consulta.component.html"  ficando da seguinte forma:
<div class="mat-elevation-z8">
  <mat-table #table [dataSource]="dataSource">
    <ng-container matColumnDef="segmento">
      <mat-header-cell *matHeaderCellDef> Segmento </mat-header-cell>
      <mat-cell *matCellDef="let element"> {{element.segmento}} </mat-cell>
    </ng-container>
    <ng-container matColumnDef="descricao">
        <mat-header-cell *matHeaderCellDef> Descrição </mat-header-cell>
        <mat-cell *matCellDef="let element"> {{element.descricao}} </mat-cell>
    </ng-container>
    <ng-container matColumnDef="dataInicio">
      <mat-header-cell *matHeaderCellDef> Início </mat-header-cell>
      <mat-cell *matCellDef="let element"> {{element.dataInicio | date:'d/M/yyy'}} </mat-cell>
    </ng-container>
    <ng-container matColumnDef="dataTermino">
      <mat-header-cell *matHeaderCellDef> Término </mat-header-cell>
      <mat-cell *matCellDef="let element"> {{element.dataTermino  | date:'d/M/yyy'}} </mat-cell>
    </ng-container>
    <ng-container matColumnDef="instrutores">
      <mat-header-cell *matHeaderCellDef> Instrutores </mat-header-cell>
      <mat-cell *matCellDef="let element"> {{element.instrutores.length}} </mat-cell>
    </ng-container>
    <ng-container matColumnDef="id">
      <mat-header-cell *matHeaderCellDef  fxFlex="10"> Ações </mat-header-cell>
      <mat-cell *matCellDef="let element" fxFlex="10" class="buttons">
         <button mat-icon-button color="primary"  matTooltip="Editar">
            <mat-icon class="md-24"  (click)="editar(element.id)" aria-label="Editar">edit</mat-icon>
          </button>
          <button mat-icon-button color="danger" matTooltip="Remover">
              <mat-icon class="md-24" (click)="remover(element.id)" aria-label="Remover">delete</mat-icon>
          </button>
      </mat-cell>
    </ng-container>
    <mat-header-row *matHeaderRowDef="displayedColumns"></mat-header-row>
    <mat-row *matRowDef="let row; columns: displayedColumns;"></mat-row>
  </mat-table>
  <div *ngIf="noResults$" class="noResult">Nenhum resultado</div>
  <button mat-fab color="primary">
    <mat-icon class="mat-24" routerLink="/main/disciplina/adicionar" aria-label="Adicionar">add</mat-icon>
  </button> 
</div>


Agora vamos só mudar as chamadas do "disciplinas/formulario.service.ts" para usar DisciplinaService ao invés de UserService;

Após isto para testarmos vamos incluir o novo módulo a rota principal do projeto em "main.routing.ts"
children: [
  {
    path: 'usuario',
    loadChildren: './usuario/usuario.module#UsuarioModule'
  },
  {
    path: 'disciplina',
    loadChildren: './disciplinas/disciplina.module#DisciplinaModule'
  }
]

Despois vamos adicionar a rota ao menu principal, em main.component.html
<mat-list-item routerLink="/main/usuario/consulta" (click)="sidenav.close()">
  <button mat-icon-button >
      <mat-icon>account_circle</mat-icon>
  </button>
  <a mdLine>Usuários</a>
</mat-list-item>
<mat-list-item routerLink="/main/disciplina/consulta" (click)="sidenav.close()">
  <button mat-icon-button >
      <mat-icon>list</mat-icon>
  </button>
  <a mdLine>Disciplinas</a>
</mat-list-item>

Após isto precisamos ajustar o layout do nosso formulário, pois os campos estão correpondento ao usuário e não a disciplinas,
Porém vamos precisar neste novo layout a listagem de professores, e um DatePicker, para isto vamos iniciar importando as classes do date picker.
No arquivo disciplina.module.ts, vamos importar os seguintes módulos:
modules:[
	...
	MatDatepickerModule,
	MatNativeDateModule,
	...
]
E vamos definir para nosso provider das datas, que nosso idioma é pt-br:
providers: [... {provide: MAT_DATE_LOCALE, useValue: 'pt-br'}]

Vamos aproveitar antes de ajustarmos nosso html, criar um service responsável pela busca de professores, podendo ser criado pelo ng -g ou podemos copiar o disciplina.service.ts e renomealo para professores.service.ts dentro da pasta /disciplinas/
Nosso professor.service.ts ficará desta forma:
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { environment } from '../../../environments/environment';
import { Observable } from 'rxjs/Observable';
import { HttpParams } from '@angular/common/http';

@Injectable()
export class ProfessorService {

  constructor(private _httpClient:HttpClient ) { }

  private _urlProfessores = environment.URL+"usuarios";

  listarProfessores(){
    let httpParams = new HttpParams().set("tipo","PROFESSOR")
    return this._httpClient.get<Array<Object>>(this._urlProfessores, {params:httpParams});
  }
}

Porém para utilizarmos no formulário precisamos incluir a dependencia no módulo então na disciplina.module.ts, vamos colocar a importação no providers.
import { ProfessorService } from './professor.service';
providers: [HttpClient,DisciplinaService,ProfessorService, FormBuilder, {provide: MAT_DATE_LOCALE, useValue: 'pt-br'}]


Então agora vamos editar o "disciplinas/formulario/formulario.componente.ts" para corresponder ao conteudo da disciplina ao invés do usuário, porém ainda sem o evento da listagem do professor:
então mudaremos public profiles para  public segmentos = [
	{ value: "Backend", description: 'Back-end' },
	{ value: "Front-end", description: 'Front-end' },
	{ value: "Mobile", description: 'Mobile' }
]
Logo após o item do identifier, vamos criar um public de professores um array vazio: [], que iremos popular no ngOnINit.
Em nosso construtor, temores um serviço a mais que será o de professores: private _professorService: ProfessorService

O formulário, que é criado no construtor por hora não vamos incluir o array de professores:
this.form = fb.group({
	id: [null],
	descricao: [null, Validators.required],
	segmento: [null, Validators.required],
	dataInicio: [null, Validators.required],
	dataTermino: [null, Validators.required],
	urlLogo: [null]
})

vamos incluir a chamada dos professores, em nosso ngOnInit, e vamos excluir as modificações de campos do alterar do usuário:
this._professorService.listarProfessores().subscribe(suc=>{
	this.professores = suc;
})

Iremos atualizar as rotas da nossa função salvar();

Nosso ts, irá conter 2 novas funções, para atualizarmos o html a função de abertura do calendário, e outra caso não carregue a imagem pela url, que o usuário informar:
failLoad(event){
    event.target.src = "https://d30y9cdsu7xlg0.cloudfront.net/png/20804-200.png";
}
openCalendar(item){
item.open();
}

Nosso formulario.componente.ts ficará da seguinte forma:
import { Component, OnInit, ViewEncapsulation, Inject } from '@angular/core';
import { DisciplinaService } from '../disciplina.service';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { EqualPasswordsValidator } from '../../../validators/equalPasswords.validator';
import { Router, ActivatedRoute } from '@angular/router';
import { ProfessorService } from '../professor.service';

@Component({
  selector: 'app-formulario',
  templateUrl: './formulario.component.html',
  styleUrls: ['./formulario.component.scss'],
  encapsulation: ViewEncapsulation.None
})
export class FormularioComponent implements OnInit {

  public segmentos = [
    { value: "Backend", description: 'Back-end' },
    { value: "Front-end", description: 'Front-end' },
    { value: "Mobile", description: 'Mobile' }
  ];


  form: FormGroup;
  identifier = null;
  professores = [];

  constructor(private _disciplinaService: DisciplinaService, 
              private fb: FormBuilder, 
              private _router: Router,
              private _activateRoute: ActivatedRoute,
              private _professorService: ProfessorService  
            ) {

    this.form = fb.group({
      id: [null],
      descricao: [null, Validators.required],
      segmento: [null, Validators.required],
      dataInicio: [null, Validators.required],
      dataTermino: [null, Validators.required],
      urlLogo: [null]
    })
  }
  
  ngOnInit() {
    this.identifier = null;    
    this._activateRoute.params.subscribe(params=>{
      this.identifier = params['id'];
    })
    this._professorService.listarProfessores().subscribe(suc=>{
      this.professores = suc;
    })
    if(this.identifier){
      this._disciplinaService.getItem(this.identifier).subscribe(suc=>{
        var item = Object(suc);
        this.form.setValue(item);
      });
    }
  }

  salvar() {
    if(this.form.valid){
      if(this.identifier){
        this._disciplinaService.editar(this.form.value).subscribe(suc=>{
          this.form.reset();
          this._router.navigate(['/main/disciplina/consulta']);
        })
      } else {
        this._disciplinaService.adicionar(this.form.value).subscribe(suc=>{
            this.form.reset();
            this._router.navigate(['/main/disciplina/consulta']);
          }
        )
      }
    }
  }

  failLoad(event){
    event.target.src = "https://d30y9cdsu7xlg0.cloudfront.net/png/20804-200.png";
  }

  openCalendar(item){
    item.open();
  }
}

Agora vamos iniciar os ajustes necessários, no disciplinas/formulario/formulario.componente.html, removendo os campos que não pertencem, ao usuário e incluindo o de disciplinas, layout que vamos seguir é este:
http://storage1.static.itmages.com/i/18/0103/h_1515014969_6724336_d90204510f.png
O que temos de diferente do usuário, são os date picker que iremos utilizar a seguinte abordagem conforme documentação do angular:
<mat-form-field fxFlex="47"> 
	<input matInput (keypress)="openCalendar(dtInicio);" formControlName="dataInicio" [matDatepicker]="dtInicio" placeholder="Data Início">
	<mat-datepicker-toggle matSuffix [for]="dtInicio"></mat-datepicker-toggle>
	<mat-datepicker #dtInicio touchUi="true"></mat-datepicker>
	<mat-error *ngIf="form.controls['dataInicio'].hasError('required')">
	  Campo obrigatório
	</mat-error>
</mat-form-field>
Sendo que o keypress, estou utilizando para forçar a abertura do datePicker, para o usuário não informar letras, documentação do datepicker, caso queira mudar os comportamentos:
https://material.angular.io/components/datepicker/overview

E temos de diferente, o comportamento do field da urlLogo, onde iremos carregar uma imagem, caso ocorra um erro, vamos deixar uma imagem default:
<div fxFlex="100" fxLayout="row">
	<mat-form-field fxFlex="75"> 
	  <input matInput formControlName="urlLogo" placeholder="Url Logo" >
	  <mat-error *ngIf="form.controls['urlLogo'].hasError('required')">
	    Campo obrigatório
	  </mat-error>
	</mat-form-field>
	<span fxFlex="5"></span>
	<img class="urlLogo" [src]="form.controls['urlLogo'].value" (error)="failLoad($event)"/>
</div>

Então no nosso start, sem o ajuste dos professores, nosso disciplinas/formulario/formulario.componente.html ficará da seguinte forma:
<div  fxLayout="column">
  <form [formGroup]="form"  fxLayout="column">
    <div fxFlex="100" fxLayout="row">  
      <mat-form-field fxFlex="47"> 
        <mat-select formControlName="segmento" placeholder="Segmento" >
            <mat-option *ngFor="let seg of segmentos" [value]="seg.value">
              {{ seg.description }}
            </mat-option>
        </mat-select>
        <mat-error *ngIf="form.controls['segmento'].hasError('required')">
          Campo obrigatório
        </mat-error>
      </mat-form-field>
      <span fxFlex="5"></span>
      <mat-form-field fxFlex="47"> 
        <input matInput formControlName="descricao" placeholder="Descrição" >
        <mat-error *ngIf="form.controls['descricao'].hasError('required')">
          Campo obrigatório
        </mat-error>
      </mat-form-field>
    </div>
    <div fxFlex="100" fxLayout="row">
      <mat-form-field fxFlex="47"> 
        <input matInput (keypress)="openCalendar(dtInicio);" formControlName="dataInicio" [matDatepicker]="dtInicio" placeholder="Data Início">
        <mat-datepicker-toggle matSuffix [for]="dtInicio"></mat-datepicker-toggle>
        <mat-datepicker #dtInicio touchUi="true"></mat-datepicker>
        <mat-error *ngIf="form.controls['dataInicio'].hasError('required')">
          Campo obrigatório
        </mat-error>
      </mat-form-field>
      <span fxFlex="5"></span>
      <mat-form-field fxFlex="47"> 
        <input matInput (keypress)="openCalendar(dtTermino);" formControlName="dataTermino" [matDatepicker]="dtTermino" placeholder="Data Término">
        <mat-datepicker-toggle matSuffix [for]="dtTermino"></mat-datepicker-toggle>
        <mat-datepicker #dtTermino touchUi="true"></mat-datepicker>
        <mat-error *ngIf="form.controls['dataTermino'].hasError('required')">
          Campo obrigatório
        </mat-error>
      </mat-form-field>
    </div>
    <div fxFlex="100" fxLayout="row">
      <mat-form-field fxFlex="75"> 
          <input matInput formControlName="urlLogo" placeholder="Url Logo" >
          <mat-error *ngIf="form.controls['urlLogo'].hasError('required')">
            Campo obrigatório
          </mat-error>
      </mat-form-field>
      <span fxFlex="5"></span>
      <img class="urlLogo" [src]="form.controls['urlLogo'].value" (error)="failLoad($event)"/>
    </div>
    <div fxFlex="100" fxLayout="row">
      <mat-form-field fxFlex="75"> 
        <mat-select  placeholder="Professores" >
            <mat-option *ngFor="let seg of segmentos" [value]="seg.value">
              {{ seg.description }}
            </mat-option>
        </mat-select>
      </mat-form-field>
      <span fxFlex="5"></span>
      <button mat-raised-button  mat-icon-button color="primary"  (click)="addProfessor()">
          <mat-icon>add</mat-icon>
      </button>
    </div>
    <br/>
    <div fxFlex="100" fxLayout="row" fxLayoutAlign="space-between">
        <button mat-raised-button color="primary"  [disabled]="!form.valid" (click)="salvar()">{{ identifier ? 'Salvar' : 'Cadastrar'}}</button>
        <button mat-raised-button color="warn" routerLink="/main/disciplina/consulta">Cancelar</button>
    </div>
  </form>
</div>


Para melhor visualização da imagem coloquei essa propertie a mais no (disciplinas/formulario/formulario.component.scss) scss:
img.urlLogo{
    height: 50px;
}


Agora, iremos realizar os ajustes necessários tanto no html quanto no ts, para que conseguimos, fazer a listagem de professores:
Primeiro vamos ajustar a listagem de professores, no html "disciplinas/formulario/formulario.component.html", ficando nosso select da seguinte forma:
<mat-select [(ngModel)]="selectProf" [ngModelOptions]="{standalone: true}" placeholder="Professores" >
    <mat-option *ngFor="let prof of professores" [value]="prof">
      {{ prof.nome }}
    </mat-option>
</mat-select>
No caso informamos: ngModelOptions como standalone, para informar que realmente vamos fazer um bind com ts sem vinculo com nosso formulário.
E no botão, de inclusão de professor, vamos inserir o (click)="addProfessor()" e desabilitarmos caso não tenha um professor selecionado.
<button mat-raised-button  mat-icon-button color="primary" [disabled]="selectProf == null" (click)="addProfessor()">
    <mat-icon>add</mat-icon>
</button>

Agora vamos ajustar nosso ts "disciplinas/formulario/formulario.component.ts", para que haja a propriedade selectProf, e criarmos a o array de professores no formulário:
Primeiro vamos incluir um array em nosso formulário, chamado instrutores:
this.form = fb.group({
  id: [null],
  descricao: [null, Validators.required],
  segmento: [null, Validators.required],
  dataInicio: [null, Validators.required],
  dataTermino: [null, Validators.required],
  urlLogo: [null],
  instrutores : fb.array([])
})

Agora vamos criar a variavel public selectProf.

Agora vamos criar a função addProfessor(), esta função, será responsável por obter o id, e marcar como já selecionado, e incluir o id no arrayForm.
addProfessor(){
  let arrayProf = (<FormArray>this.form.get("instrutores"));
  if(!arrayProf.value.includes(this.selectProf.id)){
    arrayProf.value.push(this.selectProf.id);
  }
  this.selectProf.selected = true;
  delete this.selectProf;
}

Agora vamos fazer com que nossa listagem html, remova o professor do select, e vamos criar uma listagem abaixo com opção de eclusão dos selecionados:
Vamos umsar o ng-container pois como precisamos de 2 funções do angular em DOM.
<ng-container *ngFor="let prof of professores">
  <mat-option *ngIf="!prof.selected" [value]="prof">
    {{ prof.nome }}
  </mat-option>
</ng-container>

Agora vamos criar nossa listagem, vamos usar MatListModule, para criarmos a listagem de professores, para isto precisamos primeiramente incluir essa importação em disciplinas.module.ts.
import { MatTableModule, MatIconModule, MatButtonModule, MatFormFieldModule, MatInputModule, MatTooltipModule, MatSelectModule, MatOptionModule, MatDatepickerModule, MatNativeDateModule, MAT_DATE_LOCALE, MatListModule } from '@angular/material';
modules [
  ...
  MatListModule
  ...
]

Agora vamos ajustar nosso html "disciplinas/formulario/formulario.component.html", e incluirmos a listagem
https://material.angular.io/components/list/examples
<mat-list *ngIf="form.get('instrutores').value.length > 0">
    <h3 mat-subheader>Professores selecionados</h3>
    <ng-container *ngFor="let id of form.get('instrutores').value">
      <mat-list-item>
          <button mat-mini-fab type="button" color="warn" (click)="removerProfessor(id)">
              <mat-icon>delete</mat-icon>
          </button>
          <p fxFlexOffset="10px">
            {{nomeProfessor(id)}}
          </p>
      </mat-list-item>
      <mat-divider></mat-divider>
    </ng-container>
</mat-list>
<br/>

Porém como nosso array de professor só há o ID, precisamos criar a função no TS que será responsável por retornar o nome do professor, que denominamos no html acima como nomeProfessor();
A função ficaria dessa forma em "disciplicas/formulario/formulario.component.ts"
nomeProfessor(id){
  let item = this.professores.find(item=>{ return item.id == id});
  return item ? item.nome : "Professor indisponível";
}

E também precisamos fazer a função responsável por remover um professor que denominamos como removerProfessor, então no TS "disciplicas/formulario/formulario.component.ts" vamos fazer a seguinte função.
removerProfessor(id){
  let arrayProf = (<FormArray>this.form.get("instrutores"));
  let index = arrayProf.value.findIndex(item=>{return item == id});
  if(index > -1){
    arrayProf.value.splice(index,1);
  }
  let item = this.professores.find(item=>{ return item.id == id});
  item.selected = false;
}

Agora, sabemos que precisamos de um número mínimo de professores para uma aula, vamos ajustar nosso html vamos editar para exibir a mensagem informativa sobre o minimo de professores e desabilitando o botão caso não haja.
"disciplinas/formulario/formulario.componente.html"
<mat-hint>
    Necessário pelo menos 2 professores cadastrados
</mat-hint>
[disabled]="!form.valid || form.get('instrutores').value.length < 2"

Nosso html final ficará desta forma: 
<div  fxLayout="column">
  <form [formGroup]="form"  fxLayout="column">
    <div fxFlex="100" fxLayout="row">  
      <mat-form-field fxFlex="47"> 
        <mat-select formControlName="segmento" placeholder="Segmento" >
            <mat-option *ngFor="let seg of segmentos" [value]="seg.value">
              {{ seg.description }}
            </mat-option>
        </mat-select>
        <mat-error *ngIf="form.controls['segmento'].hasError('required')">
          Campo obrigatório
        </mat-error>
      </mat-form-field>
      <span fxFlex="5"></span>
      <mat-form-field fxFlex="47"> 
        <input matInput formControlName="descricao" placeholder="Descrição" >
        <mat-error *ngIf="form.controls['descricao'].hasError('required')">
          Campo obrigatório
        </mat-error>
      </mat-form-field>
    </div>
    <div fxFlex="100" fxLayout="row">
      <mat-form-field fxFlex="47"> 
        <input matInput (keypress)="openCalendar(dtInicio);" formControlName="dataInicio" [matDatepicker]="dtInicio" placeholder="Data Início">
        <mat-datepicker-toggle matSuffix [for]="dtInicio"></mat-datepicker-toggle>
        <mat-datepicker #dtInicio touchUi="true"></mat-datepicker>
        <mat-error *ngIf="form.controls['dataInicio'].hasError('required')">
          Campo obrigatório
        </mat-error>
      </mat-form-field>
      <span fxFlex="5"></span>
      <mat-form-field fxFlex="47"> 
        <input matInput (keypress)="openCalendar(dtTermino);" formControlName="dataTermino" [matDatepicker]="dtTermino" placeholder="Data Término">
        <mat-datepicker-toggle matSuffix [for]="dtTermino"></mat-datepicker-toggle>
        <mat-datepicker #dtTermino touchUi="true"></mat-datepicker>
        <mat-error *ngIf="form.controls['dataTermino'].hasError('required')">
          Campo obrigatório
        </mat-error>
      </mat-form-field>
    </div>
    <div fxFlex="100" fxLayout="row">
      <mat-form-field fxFlex="75"> 
          <input matInput formControlName="urlLogo" placeholder="Url Logo" >
          <mat-error *ngIf="form.controls['urlLogo'].hasError('required')">
            Campo obrigatório
          </mat-error>
      </mat-form-field>
      <span fxFlex="5"></span>
      <img class="urlLogo" [src]="form.controls['urlLogo'].value" (error)="failLoad($event)"/>
    </div>
    <div fxFlex="100" fxLayout="row">
      <mat-form-field fxFlex="75"> 
        <mat-select [(ngModel)]="selectProf" [ngModelOptions]="{standalone: true}" placeholder="Professores" >
            <ng-container *ngFor="let prof of professores">
              <mat-option *ngIf="!prof.selected" [value]="prof">
                {{ prof.nome }}
              </mat-option>
            </ng-container>
        </mat-select>
        <mat-hint>
            Necessário pelo menos 2 professores cadastrados
        </mat-hint>
      </mat-form-field>
      <span fxFlex="5"></span>
      <button mat-raised-button  mat-icon-button color="primary" type="button" [disabled]="selectProf == null" (click)="addProfessor()">
          <mat-icon>add</mat-icon>
      </button>
    </div>
    <mat-list *ngIf="form.get('instrutores').value.length > 0">
        <h3 mat-subheader>Professores selecionados</h3>
        <ng-container *ngFor="let id of form.get('instrutores').value">
          <mat-list-item>
              <button mat-mini-fab type="button" color="warn" (click)="removerProfessor(id)">
                  <mat-icon>delete</mat-icon>
              </button>
              <p fxFlexOffset="10px">
                {{nomeProfessor(id)}}
              </p>
          </mat-list-item>
          <mat-divider></mat-divider>
        </ng-container>
    </mat-list>
    <br/>
    <div fxFlex="100" fxLayout="row" fxLayoutAlign="space-between">
        <button mat-raised-button color="primary"  [disabled]="!form.valid || form.get('instrutores').value.length < 2" (click)="salvar()">{{ identifier ? 'Salvar' : 'Cadastrar'}}</button>
        <button mat-raised-button color="warn" routerLink="/main/disciplina/consulta">Cancelar</button>
    </div>
  </form>
</div>

Vamos iniciar as alterações do comportamento do onInit para que atenda agora a atualização dos dados.
Primeiro vamos verficiar se o disciplina.service.ts o método getItem está como <any>
return this._httpClient.get<any>(this._urlDisciplina+"/"+identifier);

Após isto vamos alterar, o NgOnit para atribuir os valores, por parametro, para que possamos percorrer e tratar nossa combobox referente aos professores que já vierem selecionados.
ngOnInit() {
    this.identifier = null;    
    this._activateRoute.params.subscribe(params=>{
      this.identifier = params['id'];
    })
    this._professorService.listarProfessores().subscribe(suc=>{
      this.professores = suc;
    })
    if(this.identifier){
      this._disciplinaService.getItem(this.identifier).subscribe(suc=>{
        var item = suc;
        this.form.setValue({
          id: suc.id,
          descricao: suc.descricao,
          segmento: suc.segmento,
          dataInicio: suc.dataInicio,
          dataTermino: suc.dataTermino,
          urlLogo: suc.urlLogo,
          instrutores:[]
        });
        suc.instrutores.forEach(element => {
          let item = this.professores.find(item=>{ return item.id == element});
          if(item){
            this.selectProf = item;
            this.addProfessor();
          }
        });
      });
    }
  }


Com isto finalizamos nossos crud de Usuários e Disciplinas.

Aula 07 - Geração de QRCode, e exibição dos nomes dos professores, na listagem de disciplinas, e se der início do relatório.

Link documentação sobre dialog:
https://material.angular.io/components/dialog/examples

Vamos iniciar com a exibição dos nomes dos professores, então vamos criar um componente que será nosso dialog, para que possamos colocar o icone no nosso formulário chamando este pop-up.
Para isto vamos na pasta "euvim\src\app\main\disciplinas\consulta" e vamos pedir para o angular cli gerar nosso componente.
ng g component professor-dialog

Com isso ele já inseriu algumas entradas em disciplinas.module.ts porém não inseriu a entrada do component de dialog, então inserimos no NgModule
entryComponents: [ProfessorDialogComponent],

Agora dentro de "professor-dialog.component.ts" vamos remover o ngOnInit pois não iremos utilizar.
Vamos ajustar seu construtor para injeção dos dados que iremos preencher nosso dialog.
import { MatDialogRef, MAT_DIALOG_DATA } from "@angular/material";
 constructor(
    public dialogRef: MatDialogRef<ProfessorDialogComponent>,
    @Inject(MAT_DIALOG_DATA) public data: any) { }

Referente a utilização do @Inject 
https://angular-2-training-book.rangle.io/handout/di/angular2/inject_and_injectable.html


Agora precisamos ir no modulo de disciplinas.module.ts e importarmos o MatDialogModule
import { MatTableModule, MatIconModule, MatButtonModule, MatFormFieldModule, MatInputModule, MatTooltipModule, MatSelectModule, MatOptionModule, MatDatepickerModule, MatNativeDateModule, MAT_DATE_LOCALE, MatListModule, MatDialogModule } from '@angular/material';
 imports: [
   ...
   MatDialogModule,
   ...
 ]

Vamos modificar nossa listagem de disciplinas para que ele chame nossa dialog, passando o seu array de id's de professores, para que possamos iniciar as modificações necessárias.
então em "main/disciplina/consulta.component.html"
<button mat-icon-button (click)="dialogProfessores(element.instrutores)" matTooltip="Visualizar">
    {{element.instrutores.length}} 
</button>

agora em "main/disciplina/consulta.component.ts" vamos criar a função dialogProfessores para chamarmos nosso card;
vamos injetar MatDialog em nosso construtor
import { MatTableDataSource, MatDialog } from '@angular/material';
constructor(private _disciplinaService:DisciplinaService, private _router: Router, public dialog: MatDialog) { }

Agora vamos criar nossa função dialogProfessores(), 
dialogProfessores(listProf){
    let dialogRef = this.dialog.open(ProfessorDialogComponent, {
    width: '250px',
    data: { professores: listProf }
  });
}

Com isto já conseguimos visualizar nosso pop-up porém está com um HTML, informando que o component está funcionando, irei colocar a consulta dos dados, no pop-up,
Poderiamos fazer isto na camada da consulta, e já passar a listagem dos nomes tratados, porém isso pode ficar a encargo de vocês.
Para isto irei em disciplinas/professor.service.ts e criarei o método de consulta por id de professor:
getItem(id){
  let httpParams = new HttpParams().set("tipo","PROFESSOR")
  return this._httpClient.get<any>(this._urlProfessores+"/"+id, {params:httpParams});
}

Agora em professor-dialog.component.ts irei faver a injeção do professor.service.ts e realizar a chamada para ter a listagem de nomes de professores:
import { Component, OnInit, Inject } from '@angular/core';
import { MatDialogRef, MAT_DIALOG_DATA } from "@angular/material";
import { ProfessorService } from "../../professor.service";
@Component({
  selector: 'professor-dialog',
  templateUrl: './professor-dialog.component.html',
  styleUrls: ['./professor-dialog.component.scss']
})
export class ProfessorDialogComponent {
 public nomeProfessores = [];
 constructor(
    public dialogRef: MatDialogRef<ProfessorDialogComponent>,
    @Inject(MAT_DIALOG_DATA) public data: any,
    private ProfessorService : ProfessorService
  ) {
      data.professores.forEach(element => {
        this.ProfessorService.getItem(element).subscribe((suc)=>{
          this.nomeProfessores.push(suc);
        })
      });
     }
}

Agora vamos ajustar nosso HTML para que realize o ngFor com os nomes dos professores, e tenha um título, então em professor-dialog.component.html
<h1 mat-dialog-title>Instrutores</h1>
<div *ngFor="let item of nomeProfessores">
  <p>{{item.nome}} <br/> {{item.email}}</p>
</div>

Com isso finalizamos nosso card para listagem dos professores, e iremos iniciar a criação do QrCode para realizar a presença dos alunos, para não precisarmos codificar um qr code podemos utilizar de uma api do google sendo ela:
https://developers.google.com/chart/infographics/docs/qr_codes
Um exemplo:
https://chart.googleapis.com/chart?cht=qr&choe=UTF-8&chs=207x207&chl=mensagem


Então vamos replicar nossa dialog, ou criarmos um com ng g component. o nome dessa nova dialog será qr-code-dialog.
Irei criar pelo ng g component - :
Para isto vamos na pasta "euvim\src\app\main\disciplinas\consulta" e vamos pedir para o angular cli gerar nosso componente.
ng g component qr-code-dialog

Com isso ele já inseriu algumas entradas em disciplinas.module.ts porém não inseriu a entrada do component de dialog, então inserimos no NgModule
entryComponents: [ProfessorDialogComponent, QrCodeDialogComponent],

Agora dentro de "qr-code-dialog.component.ts" vamos remover o ngOnInit pois não iremos utilizar.
Vamos ajustar seu construtor para injeção dos dados que iremos preencher nosso dialog.
import { MatDialogRef, MAT_DIALOG_DATA } from "@angular/material";
 constructor(
    public dialogRef: MatDialogRef<QrCodeDialogComponent>,
    @Inject(MAT_DIALOG_DATA) public data: any) { }

Referente a utilização do @Inject 
https://angular-2-training-book.rangle.io/handout/di/angular2/inject_and_injectable.html

Vamos modificar nossa listagem de disciplinas para que ele chame nossa dialog, passando o id da disciplina, para que possamos gerar nosso qrCode.
então em "main/disciplina/consulta.component.html", vamos adicionar mais um função chamada qrCode:
<mat-header-cell *matHeaderCellDef  fxFlex="15"> Ações </mat-header-cell>
<mat-cell *matCellDef="let element" fxFlex="15" class="buttons">
    <button mat-icon-button matTooltip="QrCode">
        <mat-icon class="md-24" (click)="qrCode(element)" aria-label="QrCode">screen_lock_portrait</mat-icon>
    </button>
    <button mat-icon-button color="primary"  matTooltip="Editar">
      <mat-icon class="md-24"  (click)="editar(element.id)" aria-label="Editar">edit</mat-icon>
    </button>
    <button mat-icon-button color="warn" matTooltip="Remover">
        <mat-icon class="md-24" (click)="remover(element.id)" aria-label="Remover">delete</mat-icon>
    </button>
</mat-cell>


agora em "main/disciplina/consulta.component.ts" vamos criar a função qrCode() para chamarmos nosso card;
qrCode(item){
  let dialogRef = this.dialog.open(QrCodeDialogComponent, {
    width: '250px',
    data: { idCurso: item.id, descricao:item.descricao }
  });
}

Agora vamos ajustar nosso construtor, do qr-code-dialog.component.ts para que ele crie um link, para mostrarmos a imagem no html:
Para nosso qr code iremos atribuir, a data em ISO em um parametro do objeto e o transformalo em string de base 64;
public urlQrCode = null;
constructor(
  public dialogRef: MatDialogRef<QrCodeDialogComponent>,
  @Inject(MAT_DIALOG_DATA) public data: any) {
    data.time = new Date().toISOString()
    this.urlQrCode = "https://chart.googleapis.com/chart?cht=qr&choe=UTF-8&chs=207x207&chl="+btoa(JSON.stringify(data));
}

agora em qr-code-dialog.component.html vamos ajustar para que ele exiba a imagem do qrCode
<h1 mat-dialog-title>Presença {{data.descricao}}</h1>
<p align="center">
  <img [src]="urlQrCode" >
</p>


Pronto, agora ja temos um qrCode para presença, e a listagem de professores, agora iremos iniciar, a parte do relatório de presenças.
Para isto vamos na pasta main "euvim\src\app\main" e vamos criar o módulo de relatório
ng g module relatorio
dentro da pasta "euvim\src\app\main\relatorio" vamos criar um componente chamado presenca
ng g component presenca

agora vamos criar um arquivo na pasta "euvim\src\app\main\relatorio" chamado relatorio.routing.ts onde iremos redirecional qualquer end-point para este componente.
import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router';
import { PresencaComponent } from "./presenca/presenca.component";
@NgModule({
  imports: [
    RouterModule.forChild([
      {
        path: '**',
        component: PresencaComponent
      }
    ])
  ]
})
export class RelatorioRouting { }

E vamos atribuilo ao nosso módulo.
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule } from '@angular/router';
import { PresencaComponent } from './presenca/presenca.component';
import { RelatorioRouting } from "./relatorio.routing";

@NgModule({
  imports: [
    CommonModule,
    RouterModule,
    RelatorioRouting
  ],
  declarations: [PresencaComponent]
})
export class RelatorioModule { }

Agora vamos informar para o módulo main, que para todo end-point /relatorio carregue esse nosso módulo "main.routing.ts"
{
  path: 'relatorio',
  loadChildren: './relatorio/relatorio.module#RelatorioModule'
}

