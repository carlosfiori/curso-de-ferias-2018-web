Aula 07 - Geração de QRCode, e exibição dos nomes dos professores, na listagem de disciplinas, e se der início do relatório.

Link documentação sobre dialog:
https://material.angular.io/components/dialog/examples

Vamos iniciar com a exibição dos nomes dos professores, então vamos criar um componente que será nosso dialog, para que possamos colocar o icone no nosso formulário chamando este pop-up.
Para isto vamos na pasta "euvim\src\app\main\disciplinas\consulta" e vamos pedir para o angular cli gerar nosso componente.
ng g component professor-dialog

Com isso ele já inseriu algumas entradas em disciplinas.module.ts porém não inseriu a entrada do component de dialog, então inserimos no NgModule
entryComponents: [ProfessorDialogComponent],

Agora dentro de "professor-dialog.component.ts" vamos remover o ngOnInit pois não iremos utilizar.
Vamos ajustar seu construtor para injeção dos dados que iremos preencher nosso dialog.
import { MatDialogRef, MAT_DIALOG_DATA } from "@angular/material";
 constructor(
    public dialogRef: MatDialogRef<ProfessorDialogComponent>,
    @Inject(MAT_DIALOG_DATA) public data: any) { }

Referente a utilização do @Inject 
https://angular-2-training-book.rangle.io/handout/di/angular2/inject_and_injectable.html


Agora precisamos ir no modulo de disciplinas.module.ts e importarmos o MatDialogModule
import { MatTableModule, MatIconModule, MatButtonModule, MatFormFieldModule, MatInputModule, MatTooltipModule, MatSelectModule, MatOptionModule, MatDatepickerModule, MatNativeDateModule, MAT_DATE_LOCALE, MatListModule, MatDialogModule } from '@angular/material';
 imports: [
   ...
   MatDialogModule,
   ...
 ]

Vamos modificar nossa listagem de disciplinas para que ele chame nossa dialog, passando o seu array de id's de professores, para que possamos iniciar as modificações necessárias.
então em "main/disciplina/consulta.component.html"
<button mat-icon-button (click)="dialogProfessores(element.instrutores)" matTooltip="Visualizar">
    {{element.instrutores.length}} 
</button>

agora em "main/disciplina/consulta.component.ts" vamos criar a função dialogProfessores para chamarmos nosso card;
vamos injetar MatDialog em nosso construtor
import { MatTableDataSource, MatDialog } from '@angular/material';
constructor(private _disciplinaService:DisciplinaService, private _router: Router, public dialog: MatDialog) { }

Agora vamos criar nossa função dialogProfessores(), 
dialogProfessores(listProf){
    let dialogRef = this.dialog.open(ProfessorDialogComponent, {
    width: '250px',
    data: { professores: listProf }
  });
}

Com isto já conseguimos visualizar nosso pop-up porém está com um HTML, informando que o component está funcionando, irei colocar a consulta dos dados, no pop-up,
Poderiamos fazer isto na camada da consulta, e já passar a listagem dos nomes tratados, porém isso pode ficar a encargo de vocês.
Para isto irei em disciplinas/professor.service.ts e criarei o método de consulta por id de professor:
getItem(id){
  let httpParams = new HttpParams().set("tipo","PROFESSOR")
  return this._httpClient.get<any>(this._urlProfessores+"/"+id, {params:httpParams});
}

Agora em professor-dialog.component.ts irei faver a injeção do professor.service.ts e realizar a chamada para ter a listagem de nomes de professores:
import { Component, OnInit, Inject } from '@angular/core';
import { MatDialogRef, MAT_DIALOG_DATA } from "@angular/material";
import { ProfessorService } from "../../professor.service";
@Component({
  selector: 'professor-dialog',
  templateUrl: './professor-dialog.component.html',
  styleUrls: ['./professor-dialog.component.scss']
})
export class ProfessorDialogComponent {
 public nomeProfessores = [];
 constructor(
    public dialogRef: MatDialogRef<ProfessorDialogComponent>,
    @Inject(MAT_DIALOG_DATA) public data: any,
    private ProfessorService : ProfessorService
  ) {
      data.professores.forEach(element => {
        this.ProfessorService.getItem(element).subscribe((suc)=>{
          this.nomeProfessores.push(suc);
        })
      });
     }
}

Agora vamos ajustar nosso HTML para que realize o ngFor com os nomes dos professores, e tenha um título, então em professor-dialog.component.html
<h1 mat-dialog-title>Instrutores</h1>
<div *ngFor="let item of nomeProfessores">
  <p>{{item.nome}} <br/> {{item.email}}</p>
</div>

Com isso finalizamos nosso card para listagem dos professores, e iremos iniciar a criação do QrCode para realizar a presença dos alunos, para não precisarmos codificar um qr code podemos utilizar de uma api do google sendo ela:
https://developers.google.com/chart/infographics/docs/qr_codes
Um exemplo:
https://chart.googleapis.com/chart?cht=qr&choe=UTF-8&chs=207x207&chl=mensagem


Então vamos replicar nossa dialog, ou criarmos um com ng g component. o nome dessa nova dialog será qr-code-dialog.
Irei criar pelo ng g component - :
Para isto vamos na pasta "euvim\src\app\main\disciplinas\consulta" e vamos pedir para o angular cli gerar nosso componente.
ng g component qr-code-dialog

Com isso ele já inseriu algumas entradas em disciplinas.module.ts porém não inseriu a entrada do component de dialog, então inserimos no NgModule
entryComponents: [ProfessorDialogComponent, QrCodeDialogComponent],

Agora dentro de "qr-code-dialog.component.ts" vamos remover o ngOnInit pois não iremos utilizar.
Vamos ajustar seu construtor para injeção dos dados que iremos preencher nosso dialog.
import { MatDialogRef, MAT_DIALOG_DATA } from "@angular/material";
 constructor(
    public dialogRef: MatDialogRef<QrCodeDialogComponent>,
    @Inject(MAT_DIALOG_DATA) public data: any) { }

Referente a utilização do @Inject 
https://angular-2-training-book.rangle.io/handout/di/angular2/inject_and_injectable.html

Vamos modificar nossa listagem de disciplinas para que ele chame nossa dialog, passando o id da disciplina, para que possamos gerar nosso qrCode.
então em "main/disciplina/consulta.component.html", vamos adicionar mais um função chamada qrCode:
<mat-header-cell *matHeaderCellDef  fxFlex="15"> Ações </mat-header-cell>
<mat-cell *matCellDef="let element" fxFlex="15" class="buttons">
    <button mat-icon-button matTooltip="QrCode">
        <mat-icon class="md-24" (click)="qrCode(element)" aria-label="QrCode">screen_lock_portrait</mat-icon>
    </button>
    <button mat-icon-button color="primary"  matTooltip="Editar">
      <mat-icon class="md-24"  (click)="editar(element.id)" aria-label="Editar">edit</mat-icon>
    </button>
    <button mat-icon-button color="warn" matTooltip="Remover">
        <mat-icon class="md-24" (click)="remover(element.id)" aria-label="Remover">delete</mat-icon>
    </button>
</mat-cell>


agora em "main/disciplina/consulta.component.ts" vamos criar a função qrCode() para chamarmos nosso card;
qrCode(item){
  let dialogRef = this.dialog.open(QrCodeDialogComponent, {
    width: '250px',
    data: { idCurso: item.id, descricao:item.descricao }
  });
}

Agora vamos ajustar nosso construtor, do qr-code-dialog.component.ts para que ele crie um link, para mostrarmos a imagem no html:
Para nosso qr code iremos atribuir, a data em ISO em um parametro do objeto e o transformalo em string de base 64;
public urlQrCode = null;
constructor(
  public dialogRef: MatDialogRef<QrCodeDialogComponent>,
  @Inject(MAT_DIALOG_DATA) public data: any) {
    data.time = new Date().toISOString()
    this.urlQrCode = "https://chart.googleapis.com/chart?cht=qr&choe=UTF-8&chs=207x207&chl="+btoa(JSON.stringify(data));
}

agora em qr-code-dialog.component.html vamos ajustar para que ele exiba a imagem do qrCode
<h1 mat-dialog-title>Presença {{data.descricao}}</h1>
<p align="center">
  <img [src]="urlQrCode" >
</p>


Pronto, agora ja temos um qrCode para presença, e a listagem de professores, agora iremos iniciar, a parte do relatório de presenças.
Para isto vamos na pasta main "euvim\src\app\main" e vamos criar o módulo de relatório
ng g module relatorio
dentro da pasta "euvim\src\app\main\relatorio" vamos criar um componente chamado presenca
ng g component presenca

agora vamos criar um arquivo na pasta "euvim\src\app\main\relatorio" chamado relatorio.routing.ts onde iremos redirecional qualquer end-point para este componente.
import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router';
import { PresencaComponent } from "./presenca/presenca.component";
@NgModule({
  imports: [
    RouterModule.forChild([
      {
        path: '**',
        component: PresencaComponent
      }
    ])
  ]
})
export class RelatorioRouting { }

E vamos atribuilo ao nosso módulo.
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule } from '@angular/router';
import { PresencaComponent } from './presenca/presenca.component';
import { RelatorioRouting } from "./relatorio.routing";

@NgModule({
  imports: [
    CommonModule,
    RouterModule,
    RelatorioRouting
  ],
  declarations: [PresencaComponent]
})
export class RelatorioModule { }

Agora vamos informar para o módulo main, que para todo end-point /relatorio carregue esse nosso módulo "main.routing.ts"
{
  path: 'relatorio',
  loadChildren: './relatorio/relatorio.module#RelatorioModule'
}

Vamos ajustar nosso menu para que o link de relatório envie para este endereço "main.component.html":
<mat-list-item>
    <button mat-icon-button >
        <mat-icon>info</mat-icon>
    </button>
  <a mdLine routerLink="/main/relatorio"  (click)="sidenav.close()">Relatório</a>
</mat-list-item>


Agora vamos iniciar nosso relatório, porém temos um serviço que é comum, entre disciplinas e o relatório que é a obtenção da listagem.
Podemos extrair este service para uma camada acima, juntamente com o validators, criarmos uma nova pasta chamada services
E nela deixarmos este serviço, para que ambos os módulos chamem ele, e assim um módulo não depender do outro, e sem do TS comum.

Para isto recortamos o disciplina.service.ts para a pasta /services/disciplina.service.ts, 
ajustamos sua importação referente ao environment
import { environment } from '../../environments/environment';

depois ajustamos a importação do módulo disciplina.module.ts
import { DisciplinaService } from '../../services/disciplina.service';

e ajustamos também a importação nos componentes de disciplinas:
consulta.component.ts e formulario.component.ts
import { DisciplinaService } from '../../../services/disciplina.service';

Com isto nosso serviço ficou externalizado do módulo e podendo ser chamado por outros módulos, sem dependencia modular de um para outro.
Assim vamos utilizar este serviço no nosso relatorio.module.ts

Agora vamos criar o novo serviço chamado relatorio.service.ts dentro da pasta, "main/relatorio" 
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs/Observable';
import { environment } from '../../../environments/environment';
@Injectable()
export class RelatorioService {

  constructor(private _httpClient:HttpClient ) { }
  private _urlRelatorio = environment.URL+"relatorio";
  getPresencaDisciplina(disciplina){
    return this._httpClient.get<Array<any>>(this._urlRelatorio+"/"+disciplina);
  }
}

Levando em consideração o layout que queremos fazer, vamos precisar importar estes serviços e alguns componentes do angular material, nosso relatorio.module.ts ficaria com as seguintes dependencias:
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule } from '@angular/router';
import { PresencaComponent } from './presenca/presenca.component';
import { RelatorioRouting } from "./relatorio.routing";
import { MatIconModule, MatButtonModule, MatFormFieldModule, MatInputModule, MatTooltipModule, MatSelectModule, MatOptionModule, MatDatepickerModule, MatNativeDateModule, MatListModule, MatDialogModule, MAT_DATE_LOCALE, MatExpansionModule } from '@angular/material';
import { FlexLayoutModule } from '@angular/flex-layout';
import { ReactiveFormsModule, FormsModule, FormBuilder } from '@angular/forms';
import { HttpClientModule, HttpClient } from '@angular/common/http';
import { DisciplinaService } from '../../services/disciplina.service';
import { RelatorioService } from './relatorio.service';

@NgModule({
  imports: [
    CommonModule,
    RouterModule,
    RelatorioRouting,
    MatIconModule,
    MatButtonModule,
    MatFormFieldModule,
    MatInputModule,
    FlexLayoutModule,
    MatTooltipModule,
    MatSelectModule, 
    MatOptionModule,
    ReactiveFormsModule,
    FormsModule,
    MatDatepickerModule,
    MatNativeDateModule,
    MatListModule,
    MatDialogModule,
    MatExpansionModule,
    HttpClientModule
  ],
  declarations: [PresencaComponent],
  providers: [HttpClient,FormBuilder, DisciplinaService, RelatorioService , {provide: MAT_DATE_LOCALE, useValue: 'pt-br'}]
})
export class RelatorioModule { }


Agora iniciaremos a criação do nosso HTML (presenca.component.html), incluindo campos e formulário, sem vinculos com o ts, para manipulação inicial:
Vamos criar um Painel Expansivo para os filtros, e sua listagem também será comporta com o painel:
http://storage1.static.itmages.com/i/18/0108/h_1515441375_3008489_e99c436cdd.png

e nossa listagem quando filtrarmos ficará desta forma com painel expansivo:
http://storage4.static.itmages.com/i/18/0108/h_1515441415_6753914_d4eceb5926.png

Por horá só tem html, e variaveis manipuladas pelo pŕoprio html, sem nenhum fluxo implementado no ts:
variavel utilizada no html para comportamento do filtro é a "filtred" e utilizamos as mesmas chamadas do calendário da tela anterior: (keypress)="openCalendar(dtInicio);"

Abaixo o html (como pode ver já deixei comentado nossas tag de erro referente ao formulário que vamos manipular):
<div class="mat-elevation-z8">
  <mat-accordion class="example-headers-align">
    <mat-expansion-panel [expanded]="!filtred" (opened)="filtred = false" hideToggle="true">
      <mat-expansion-panel-header>
        <mat-panel-title fxFlex="70">
          <mat-icon>filter_list</mat-icon> 
          <div fxFlexOffset="10px"> Filtros</div>
        </mat-panel-title>
      </mat-expansion-panel-header>  
      <form fxLayout="column">
        <div fxFlex="100" fxLayout="row">  
          <mat-form-field fxFlex="47"> 
            <mat-select  placeholder="Disciplina" >
                <mat-option *ngFor="let disc of disciplinas"  [value]="disc.id">
                  {{ disc.descricao }}
                </mat-option>
            </mat-select>
            <!--mat-error *ngIf="form.controls['disciplina'].hasError('required')">
              Campo obrigatório
            </mat-error-->
          </mat-form-field>
        </div>
        <div fxFlex="100" fxLayout="row">
          <mat-form-field fxFlex="47"> 
            <input matInput (keypress)="openCalendar(dtInicio);"  [matDatepicker]="dtInicio" placeholder="Data Início">
            <mat-datepicker-toggle matSuffix [for]="dtInicio"></mat-datepicker-toggle>
            <mat-datepicker #dtInicio touchUi="true"></mat-datepicker>
            <!--mat-error *ngIf="form.controls['dataInicio'].hasError('required')">
              Campo obrigatório
            </mat-error-->
          </mat-form-field>
          <span fxFlex="5"></span>
          <mat-form-field fxFlex="47"> 
            <input matInput (keypress)="openCalendar(dtTermino);"  [matDatepicker]="dtTermino" placeholder="Data Término">
            <mat-datepicker-toggle matSuffix [for]="dtTermino"></mat-datepicker-toggle>
            <mat-datepicker #dtTermino touchUi="true"></mat-datepicker>
            <!--mat-error *ngIf="form.controls['dataTermino'].hasError('required')">
              Campo obrigatório
            </mat-error-->
          </mat-form-field>
        </div>
        <br/>
        <div fxFlex="100" fxLayout="row" fxLayoutAlign="space-between">
            <button mat-raised-button (click)="filtred=true" color="primary" >Filtrar</button>
        </div>
      </form>
    </mat-expansion-panel>
  </mat-accordion>
</div>
<br/>
<div *ngIf="filtred" class="mat-elevation-z8">

  <mat-accordion>
    <mat-expansion-panel>
      <mat-expansion-panel-header>
        <mat-panel-title fxFlex="70">
          José
        </mat-panel-title>
        <mat-panel-description>
          Frequência 10%
        </mat-panel-description>
      </mat-expansion-panel-header>

      <mat-list>
        <h3 matSubheader>Presenças</h3>
        <mat-list-item>
          <mat-icon matListIcon>check</mat-icon>
          <h3 matLine> Presente </h3>
          <p matLine>
            <span> XX/XX/XXXX </span>
          </p>
        </mat-list-item>
        <mat-divider></mat-divider>
        <mat-list-item>
            <mat-icon matListIcon>remove</mat-icon>
            <h3 matLine> Ausência </h3>
            <p matLine>
              <span> XX/XX/XXXX </span>
            </p>
          </mat-list-item>
        <mat-divider></mat-divider>
      </mat-list>

    </mat-expansion-panel>
  </mat-accordion>
</div>

Agora vamos iniciar nosso ts, criando inicialmente nosso formulário para que possamos ajustar nosso comportamento do formulário.
openCalendar(item){
  item.open();
}

Agora vamos obter a lista de disciplinas, primeiro injetamos a disciplina depois atribuimos a listagem disciplinas:
  import { DisciplinaService } from '../../../services/disciplina.service';

  public disciplinas=[];

  constructor(private _disciplinaService:DisciplinaService) { }

  ngOnInit() {
    this._disciplinaService.listar().subscribe(suc=>{
      this.disciplinas = suc;
    })
  }

Com isto nossa listagem já começara a funcionar, agora vamos criar nosso formulário para validarmos a request, e habilitar/desabilitar o botão filtrar, e realizarmos a ação de busca:
import { Component, OnInit } from '@angular/core';
import { DisciplinaService } from '../../../services/disciplina.service';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { RelatorioService } from '../relatorio.service';

@Component({
  selector: 'app-presenca',
  templateUrl: './presenca.component.html',
  styleUrls: ['./presenca.component.scss']
})
export class PresencaComponent implements OnInit {

  public filtred: boolean;
  public disciplinas = [];
  public relatorio=[];
  public form: FormGroup;

  constructor(private _disciplinaService: DisciplinaService,
              private _relatorioService: RelatorioService,
              private _form: FormBuilder) {
    this.form = this._form.group({
      disciplina: [null, Validators.required],
      dataInicio: [null, Validators.required],
      dataFim: [null, Validators.required]
    })
  }

  ngOnInit() {
    this._disciplinaService.listar().subscribe(suc => {
      this.disciplinas = suc;
    })
  }

  openCalendar(item) {
    item.open();
  }

  gerarRelatorio() {
    this.filtred = []
    this.relatorio=null;
    this._relatorioService.getPresencaDisciplina(this.form.value).subscribe(suc=>{
      this.relatorio = suc;
    })
  }
}

Agora ajustamos o html, para bloquear o botão filtrar e realizar o ngIf referente aos usuários presentes:
<div class="mat-elevation-z8">
  <mat-accordion class="example-headers-align">
    <mat-expansion-panel [expanded]="!filtred" [disabled]="!filtred" (opened)="filtred = false" hideToggle="true">
      <mat-expansion-panel-header>
        <mat-panel-title fxFlex="70">
          <mat-icon>filter_list</mat-icon> 
          <div fxFlexOffset="10px"> Filtros</div>
        </mat-panel-title>
      </mat-expansion-panel-header>  
      <form [formGroup]="form" fxLayout="column">
        <div fxFlex="100" fxLayout="row">  
          <mat-form-field fxFlex="47"> 
            <mat-select formControlName="disciplina"  placeholder="Disciplina" >
                <mat-option *ngFor="let disc of disciplinas" [value]="disc.id">
                  {{ disc.descricao }}
                </mat-option>
            </mat-select>
            <mat-error *ngIf="form.controls['disciplina'].hasError('required')">
              Campo obrigatório
            </mat-error>
          </mat-form-field>
        </div>
        <div fxFlex="100" fxLayout="row">
          <mat-form-field fxFlex="47"> 
            <input matInput (keypress)="openCalendar(dtInicio);" formControlName="dataInicio"  [matDatepicker]="dtInicio" placeholder="Data Início">
            <mat-datepicker-toggle matSuffix [for]="dtInicio"></mat-datepicker-toggle>
            <mat-datepicker #dtInicio touchUi="true"></mat-datepicker>
            <mat-error *ngIf="form.controls['dataInicio'].hasError('required')">
              Campo obrigatório
            </mat-error>
          </mat-form-field>
          <span fxFlex="5"></span>
          <mat-form-field fxFlex="47"> 
            <input matInput (keypress)="openCalendar(dtTermino);" formControlName="dataFim"  [matDatepicker]="dtTermino" placeholder="Data Término">
            <mat-datepicker-toggle matSuffix [for]="dtTermino"></mat-datepicker-toggle>
            <mat-datepicker #dtTermino touchUi="true"></mat-datepicker>
            <mat-error *ngIf="form.controls['dataFim'].hasError('required')">
              Campo obrigatório
            </mat-error>
          </mat-form-field>
        </div>
        <br/>
        <div fxFlex="100" fxLayout="row" fxLayoutAlign="space-between">
            <button mat-raised-button (click)="gerarRelatorio()" [disabled]="!form.valid" color="primary" >Filtrar</button>
        </div>
      </form>
    </mat-expansion-panel>
  </mat-accordion>
</div>
<br/>
<div *ngIf="filtred" class="mat-elevation-z8">

  <mat-accordion>
    <mat-expansion-panel *ngFor="let item of relatorio">
      <mat-expansion-panel-header>
        <mat-panel-title fxFlex="70">
          {{item.usuario.nome}}
        </mat-panel-title>
        <mat-panel-description>
          Frequência {{item.frequencia}} %
        </mat-panel-description>
      </mat-expansion-panel-header>
      <mat-list>
        <h3 matSubheader>Presenças</h3>
        <mat-list-item>
          <mat-icon matListIcon>check</mat-icon>
          <h3 matLine> Presente </h3>
          <p matLine>
            <span> XX/XX/XXXX </span>
          </p>
        </mat-list-item>
        <mat-divider></mat-divider>
        <mat-list-item>
            <mat-icon matListIcon>remove</mat-icon>
            <h3 matLine> Ausência </h3>
            <p matLine>
              <span> XX/XX/XXXX </span>
            </p>
          </mat-list-item>
        <mat-divider></mat-divider>
      </mat-list>
    </mat-expansion-panel>
  </mat-accordion>
</div>

Porém nossa listagem, vai ficar extensa fazendo o HTML, vamos criar um component e usar Input para fazer esse detalhe.
Então dentro da pasta, "main/relatorio/presenca" vamos executar o comando para criarmos nosso novo componente:
ng g component item-presenca
com isto ele gerará nosso componente com um seletor padrão de nome "app-item-presenca".

Agora vamos colocar ele na listagem para vermos se está funcionando, então em presenca.component.html colocamos a nova tag:
app-item-presenca, subistituindo nossa listagem
<mat-accordion>
  <mat-expansion-panel *ngFor="let item of relatorio">
    <mat-expansion-panel-header>
      <mat-panel-title fxFlex="70">
        {{item.usuario.nome}}
      </mat-panel-title>
      <mat-panel-description>
        Frequência {{item.frequencia}} %
      </mat-panel-description>
    </mat-expansion-panel-header>
    <app-item-presenca></app-item-presenca>
  </mat-expansion-panel>
</mat-accordion>

Como pode ver nossa listagem de presença já é nosso novo component, então pensando em nosso fluxo precisamos de algumas entradas para o nosso item-presenca.compoent.ts;
import { Component, OnInit, ViewEncapsulation, Input } from '@angular/core';

@Input("dataInicio")
private cursoInicio:Date;
@Input("dataFim")
private cursoFim:Date;
@Input()
private periodoInicial:Date;
@Input()
private periodoFinal:Date;
@Input()
private presencas:Array<Date>;

Os dois primeiros items mostra que podemos obter com um nome no html o valor, desssa propriedade e dentro de nosso TS ela se referenciar a outra campo;

Como pode ver vamos ter muita manipulação de datas, neste contexto, então para isto vamos instalar uma lib chamada momment.js que será responsável por calculos entre outras funções em nosso projeto;
Para isto vamos executar o seguinte comando, na raiz do projeto:
npm install moment --save
https://momentjs.com/

"item-presenca.component.ts" vamos deixar a seguinte lógica para geração do nosso relatório usando moment
import { Component, OnInit, ViewEncapsulation, Input } from '@angular/core';
import * as moment from 'moment';

@Component({
  selector: 'app-item-presenca',
  templateUrl: './item-presenca.component.html',
  styleUrls: ['./item-presenca.component.scss'],
  encapsulation: ViewEncapsulation.None
})
export class ItemPresencaComponent implements OnInit {

  @Input("dataInicio")
  private cursoInicio:Date;
  @Input("dataFim")
  private cursoFim:Date;
  @Input()
  private periodoInicial:Date;
  @Input()
  private periodoFinal:Date;
  @Input()
  private presencas:Array<any>=[];

  public listPresenca=[];

  constructor() { }

  ngOnInit() {
    let inicio = moment(this.cursoInicio).isSameOrAfter(this.periodoInicial) ? this.cursoInicio : this.periodoInicial;   
    let fim = moment(this.cursoFim).isSameOrBefore(this.periodoFinal) ? this.cursoFim : this.periodoFinal;
    let dataCurso = moment(inicio);
    while(dataCurso.isSameOrBefore(fim)){
      if(dataCurso.weekday()>0 && dataCurso.weekday()<6){
        this.listPresenca.push({date: dataCurso.toDate(), presente : this.presencas.includes(dataCurso.format("YYYY-MM-DD")) })
      }
      dataCurso.add(1, 'days');
    } 
  }

}


Agora vamos ajustar nosso html para exibição dos dados de presença dos alunos em item-presenca.component.html:
<mat-list>
  <h3 matSubheader>Presenças</h3>
  <ng-container *ngFor="let item of listPresenca">
    <mat-list-item>
      <mat-icon matListIcon>{{item.presente ? 'check' : 'remove'}}</mat-icon>
      <h3 matLine>{{item.presente ? 'Presente' : 'Ausente'}} </h3>
      <p matLine>
        <span>{{item.date | date:'d/M/y'}} </span>
      </p>
    </mat-list-item>
    <mat-divider></mat-divider>
  </ng-container>
</mat-list>


Agora com isso vamos ajustar nossa implementação, no presenca.component.ts para que tenhamos o item da disciplina que enviamos na request, para obter suas datas e posteriormente passarmos no html
gerarRelatorio() {
    this.filtred = true
    this.relatorio=null;
    this.disciplina = this.disciplinas.find((item) => { return item.id = this.form.value.disciplina });
    this._relatorioService.getPresencaDisciplina(this.form.value).subscribe(suc=>{
      this.relatorio = suc;
    })
  }

Agora vamos ajustar nosso html presenca.component.html para que agora vamos informar os parametros do nosso componente.
<app-item-presenca *ngIf="item.show" [dataInicio]="disciplina.dataInicio" [dataFim]="disciplina.dataTermino" [periodoInicial]="form.value.dataInicio" [periodoFinal]="form.value.dataFim" [presencas]="item.presenca" ></app-item-presenca>

Porém como podem ver ficou as linhas do mat-divider, sobrepondo o card, então vamos ajustar o css do nosso item-presenca.component.scsss colocando o seguinte css:
.mat-card .mat-divider{
    position: unset;
    left: unset;
}

Antes de finalizarmos este item, podemos ver que nossa request, para obtenção do relatório está com as datas, com formatação diferente que o servidor vai aceitar, então vamos usar o moment para ajustar:
de: http://storage6.static.itmages.com/i/18/0110/h_1515576329_2979360_5212df7eb0.png
para: http://storage2.static.itmages.com/i/18/0110/h_1515576486_2191796_581722cf2c.png

No arquivo "relatorio.service.ts" vamos importar a lib moment, e utilizar o seu método format:
import { Injectable } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { Observable } from 'rxjs/Observable';
import { environment } from '../../../environments/environment';
import * as moment from 'moment';

@Injectable()
export class RelatorioService {

  constructor(private _httpClient:HttpClient ) { }

  private _urlRelatorio = environment.URL+"relatorio";

  getPresencaDisciplina(filter){
    let httpParams = new HttpParams().append("dataInicio",moment(filter.dataInicio).format("YYYY-MM-DDD"))
                                     .append("dataFim",moment(filter.dataFim).format("YYYY-MM-DDD"));
    return this._httpClient.get<Array<any>>(this._urlRelatorio+"/"+filter.disciplina, {params:httpParams});
  }
}

Pronto com isto finalizamos um relatório.


Aula 08 - Criar o Login, SessionStorage, AuthGuard, Interceptor

Vamos iniciar pela criação do nosso módulo de login, dentro da nossa pasta app.
ng g module login
ng g component login
dentro da pasta "login" cd login
ng g service login

Após isto vamos criar nosso login.routing.ts
import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router';
import { LoginComponent } from './login.component';

@NgModule({
  imports: [
    RouterModule.forChild([
      { path: 'login', 
        component: LoginComponent,
      }
    ])
  ]
})
export class LoginRouting { }

Depois atualizaremos nosso módulo login.module.ts para importar nossa rota, provider.
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { LoginComponent } from './login.component';
import { LoginRouting } from './login.routing';
import { RouterModule } from "@angular/router";
import { HttpClientModule, HttpClient } from '@angular/common/http';
import { LoginService } from './login.service';

@NgModule({
  imports: [
    CommonModule,
    RouterModule,
    LoginRouting,
    HttpClientModule
  ],
  declarations: [LoginComponent],
  providers: [HttpClient, LoginService ]
})
export class LoginModule { }

Após isto precisamos ajustar nosso app.module para importar este módulo.
import { LoginModule } from './login/login.module';
  imports: [
    BrowserModule,
    BrowserAnimationsModule,
    RouterModule,
    MainModule,
    AppRoutingModule,
    LoginModule
  ]

Agora vamos ajustar nosso app.routing.ts para redirecionar sempre para nossa tela de login ao invés de da main, caso não haja main em nosso path;
import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router';

@NgModule({
  imports: [
    RouterModule.forRoot([
      { path: 'main', redirectTo: '/main', pathMatch: 'full' },
      { path: '**', redirectTo: '/login', pathMatch: 'full' }
    ], {useHash:true})
  ]
})
export class AppRoutingModule { }

Pronto agora quando entrarmos no site, deve aparece nossa tela de login atualmente somente com texto padrão:
http://localhost:4200


Antes de criarmos nosso HTML vamos adicionar o módulo para utilizar o fxFlex em (login.module.ts);
import { FlexLayoutModule } from "@angular/flex-layout";
imports: [..
 FlexLayoutModule
..]
https://github.com/angular/flex-layout/wiki/Responsive-API

Vamos então criar nosso HTML, que será nosso login, caso utilizemos components do angular material não esqueça de importá-los em sue módulo =]
<div fxFlexFill fxLayout="column" fxLayoutAlign="center"> 
  <div fxLayout="row" fxLayoutWrap fxLayoutAlign="center"> 
    <div fxFlex="500px" fxFlex.xs="90">
      <mat-card class="mat-elevation-z7">
          <mat-card-header fxLayoutAlign="center">
            <mat-card-title> <img src="./assets/img/logo.png"/> </mat-card-title>
            <mat-card-subtitle fxLayoutAlign="center">Autenticação Necessária</mat-card-subtitle>
          </mat-card-header>
          <mat-card-content>
            <form fxLayout="column">
              <mat-form-field>
                  <input matInput placeholder="Usuário" value="">
              </mat-form-field>
              <mat-form-field>
                  <input matInput placeholder="Senha" value="" type="password">
              </mat-form-field>
              <button mat-raised-button (click)="login = true" type="button" color="primary">Login</button>
            </form>
          </mat-card-content>
        </mat-card>
        <mat-progress-bar *ngIf="login" mode="indeterminate"> </mat-progress-bar>
    </div> 
  </div>
</div>

Porém nosso html ainda não tem faz nenhuma chamada para o ts, e estamos usando uma logo, que será criado na pasta assets uma pasta /img/logo.png


Agora vamos ajustar nosso login.component.ts, para que possamos incluir comportamentos na tela de login, campos obrigatórios, disabilitar botão, mensagem de erro. entre outros.
import { Component, OnInit, ViewEncapsulation } from '@angular/core';
import { FormGroup, Validators, FormBuilder } from '@angular/forms';

@Component({
  selector: 'app-login',
  templateUrl: './login.component.html',
  styleUrls: ['./login.component.scss'],
  encapsulation: ViewEncapsulation.None
})
export class LoginComponent implements OnInit {

  public form:FormGroup;
  public login:boolean = false;

  constructor(private _form:FormBuilder) {
    this.form  = _form.group({
      "usuario": [null, Validators.compose([Validators.required, Validators.email])],
      "senha"  : [null, Validators.required]
    })
   }

  ngOnInit() {
  }

  realizarLogin(){
    this.login = true;
  }
}

Porém para realizar a criação do formulário precisamos importar os módulos, e seu provider, então ficando da seguinte form o login.module.ts
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { LoginComponent } from './login.component';
import { LoginRouting } from './login.routing';
import { RouterModule } from "@angular/router";
import { FlexLayoutModule } from "@angular/flex-layout";
import { HttpClientModule, HttpClient } from '@angular/common/http';
import { LoginService } from './login.service';
import { MatCardModule, MatInputModule, MatButtonModule, MatProgressBarModule } from '@angular/material';
import { FormsModule, ReactiveFormsModule, FormBuilder } from '@angular/forms';

@NgModule({
  imports: [
    CommonModule,
    RouterModule,
    LoginRouting,
    HttpClientModule,
    FlexLayoutModule,
    MatCardModule,
    MatInputModule,
    MatButtonModule,
    MatProgressBarModule,
    FormsModule,
    ReactiveFormsModule,
  ],
  declarations: [LoginComponent],
  providers: [HttpClient, LoginService, FormBuilder ]
})
export class LoginModule { }


Agora vamos incluir, nosso form, as labels de erro, evento do botão de realizar o login no arquivo, login.component.html:
<div fxFlexFill fxLayout="column" fxLayoutAlign="center"> 
  <div fxLayout="row" fxLayoutWrap fxLayoutAlign="center" class="overflowScroll"> 
      <div fxFlex="500px" fxFlex.xs="90">
        <mat-card class="mat-elevation-z7">
            <mat-card-header fxLayoutAlign="center">
              <mat-card-title> <img src="./assets/img/logo.png"/> </mat-card-title>
              <mat-card-subtitle fxLayoutAlign="center">Autenticação Necessária</mat-card-subtitle>
            </mat-card-header>
            <mat-card-content>
              <form fxLayout="column" [formGroup]="form">
                <mat-form-field>
                    <input matInput formControlName="usuario" placeholder="Usuário" value="">
                    <mat-error *ngIf="form.controls['usuario'].hasError('required')">
                        Campo obrigatório
                    </mat-error>
                    <mat-error *ngIf="!form.controls['usuario'].hasError('required') && form.controls['usuario'].hasError('email')">
                        E-mail Inválido
                    </mat-error>
                </mat-form-field>
                <mat-form-field>
                    <input matInput formControlName="senha" placeholder="Senha" value="" type="password">
                    <mat-error *ngIf="form.controls['senha'].hasError('required')">
                        Campo obrigatório
                    </mat-error>
                </mat-form-field>
                <br/>
                <button mat-raised-button [disabled]="!form.valid" (click)="realizarLogin()" type="button" color="primary">Login</button>
              </form>
            </mat-card-content>
          </mat-card>
          <mat-progress-bar *ngIf="login" mode="indeterminate"> </mat-progress-bar>
      </div> 
  </div>
</div>

Após isto vamos precisar criar, um service, que irá realizar o login, no nosso mock, e atribuir, a uma sessionStorage / LocalStorage o token de acesso do usuário:
Então na pasta login, vamos adicionar 2 chamadas no nosso login.service.ts para realizar o login e logout:
import { Injectable } from '@angular/core';
import { environment }  from '../../environments/environment'
import { HttpClient } from '@angular/common/http';
import { Router } from '@angular/router';
import { Observable } from 'rxjs/Observable';
import { Promise } from 'q';

@Injectable()
export class LoginService {

  private urlLogin = environment.URL+"login";

  constructor(private _httpCliente: HttpClient, private _router:Router) { }

  public login(dados) {
    return this._httpCliente.post(this.urlLogin,dados);
 }

  public deslogar(){
    sessionStorage.removeItem("access");
    this._router.navigate(["/login"]);
  }

}


Agora, vamos fazer com que nosso login chame (login.component.ts), nossa autenticação, e incluirmos no onInit, a atribuição de false do loading;
E vamos ajustar nossa chamada de login para realizar a inclusão dos dados so sessionStorage

  public form:FormGroup;
  public login:boolean = false;
  public erro;

 ngOnInit() {
    this.erro = null;
    this.login = false;
  }
  
 realizarLogin(){
    this.login = true;
    this._loginService.login(this.form.value).subscribe(suc=>{
      sessionStorage.setItem("access", JSON.stringifysuc));
      this._router.navigate(["/main"]);
      this.login = false;
    },err=>{
      this.login = false;
      this.erro = err;
    })
  }

Para o redicionamento temos que injetar o Router
constructor(private _form:FormBuilder, private _loginService : LoginService, private _router:Router) {

- Agora já estamos realizando o login e adicionando o token do nosso user na sessionStorage, agora vamos criar um AuthGuard, para validar se temos esse token, e caso não tenha ir para tela de login;
Porém, esse AuthGuard só terá efeito na rotas do main, onde de fato precisamos de acesso com token;
Vamos então dentro da pasta main, digitar o seguinte comando:
ng generate guard Auth

Após isto vamos incluir no módulo, o AuthGuard do main.module.ts
import { AuthGuard } from './auth.guard';
providers: [AuthGuard]

Depois vamos importálo nas rotas, main.routing.ts
import { AuthGuard } from './auth.guard';
path: 'main', 
canActivate: [AuthGuard],


Após isto vamos ajustar nossso authguard para validar o token no sessionStorage:
import { Injectable } from '@angular/core';
import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, Router } from '@angular/router';
import { Observable } from 'rxjs/Observable';

@Injectable()
export class AuthGuard implements CanActivate {
  constructor(private _router:Router){

  }
  canActivate(
    next: ActivatedRouteSnapshot,
    state: RouterStateSnapshot): Observable<boolean> | Promise<boolean> | boolean {
      let item = JSON.parse(sessionStorage.getItem("access"));
      let validacao = item && item.token != null;
      if(!validacao){
        this._router.navigate(["/login"]);
      }
      return validacao;
  }
}


Vamos atualizar o login component para na hora de incialização ele limpe o sessionStorage, para quando tiver o redicionamento do auth;
  ngOnInit() {
    sessionStorage.clear();
    this.erro = null;
    this.login = false;
  }

Pronto, finalizamos o AuthGuard, o que acontece, ele faz essa validação antes de abrir a rota, caso acesse, ele manda o user para tela de login.

Agora, temos que inserir o token em todas requisições de nossos módulos, então vamos editar os headers 1 a 1... #sqn
Vamos criar um interceptor para adicionar o token em, toda request, entãona pasta services vamos criar um service chamado auth.interceptor:
import { Injectable } from '@angular/core';
import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpResponse, HttpErrorResponse } from '@angular/common/http';
import { Observable } from 'rxjs/Observable';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {

  constructor() { }
  
  intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    let item = JSON.parse(sessionStorage.getItem("access"));
    let validacao = item && item.token != null;
    if(validacao){
      request = request.clone({
        setHeaders: {
          Authorization: `Bearer ${item.token}`
        }
      });
      return next.handle(request);
    }
  }
}

E vamos importálo em todo módulo que vamos usar, que são eles, relatorio.module.ts, usuario.module.ts e disciplinas.module.ts:
providers: [
  ....
  {
    provide: HTTP_INTERCEPTORS,
    useClass: AuthInterceptor,
    multi: true
  }
]

Pronto assim todas nossas request deste módulos terão o conteúdo headers com o Authorization e o token;


Aula 09 - Interceptor de error, criar loading, Model

E agora nossa aplicação não tem pop-up referente a erros, como podemos ajustar isto, vamos criar um interceptor para mostrar o pop-up de erro caso haja, e se for sem autorização mostrar o pop-up e o redirecionar, para o login;
Para não precisarmos fazer várias importações de components em módulos onde não mostra dialog, vamos criar um módulo dentro da pasta "app" chamdo messageDialog, 
então dentro da pasta app vamos digitar os seguitnes comandos:
ng g module requestError
ng g component requestError

Antes vamos precisar criar um interceptor, por hora com uma validação simples de erro, só para testarmos nosso módulo:
import { Injectable } from '@angular/core';
import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpResponse, HttpErrorResponse } from '@angular/common/http';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/operator/do';
import { RequestErrorComponent } from './request-error.component';
import { MatDialog } from '@angular/material';

@Injectable()
export class ErrorInterceptor implements HttpInterceptor {

  constructor(private dialog:MatDialog) { }
  
  intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    
    return next.handle(request).do((event: HttpEvent<any>) => {}, (err: any) => {
      if (err instanceof HttpErrorResponse) {
        this.openDialog({});
        if (err.status === 401) {
          this.openDialog({});
        }
      }else{

      }
    });
  }

  private openDialog(info){
    this.dialog.open(RequestErrorComponent, {
      data: info
    });
  }

}

Agora vamos realizar a importação do nosso interceptor em nosso módulo, request-error.module.ts, e realizar os ajustes para utilização do pop-up, entryComponents....

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RequestErrorComponent } from './request-error.component';
import { MatDialogModule } from '@angular/material';
import { HTTP_INTERCEPTORS } from '@angular/common/http';
import { ErrorInterceptor } from './error.interceptor';

@NgModule({
  imports: [
    CommonModule,
    MatDialogModule
  ],
  declarations: [RequestErrorComponent],
  entryComponents: [RequestErrorComponent],
  exports: [RequestErrorComponent, MatDialogModule],
  providers: [
    {
      provide: HTTP_INTERCEPTORS,
      useClass: ErrorInterceptor,
      multi: true
    }
  ]
})
export class RequestErrorModule { }

Como podem ver foi exportado nosso component para acessibilidade, sem importação explicita, e sua dependencia do Material.

Agora vamos ajustar nosso request-error.component.ts para utilizarmos o contrutor data:
import { Component, OnInit, ViewEncapsulation, Inject } from '@angular/core';
import { MAT_DIALOG_DATA } from '@angular/material';

@Component({
  selector: 'app-request-error',
  templateUrl: './request-error.component.html',
  styleUrls: ['./request-error.component.scss'],
  encapsulation: ViewEncapsulation.None
})
export class RequestErrorComponent {

  constructor(@Inject(MAT_DIALOG_DATA) public data: any) {}

}

Agora vamos importar nos módulos, disciplina.module.ts, usuario.module.ts, relatorio.module.ts nosso módulo 
import {RequestErrorModule} from '../../request-error/request-error.module';

Com isto caso haja um erro de request, ele já mostrará nosso pop-up, desabilite o cors, e veja.

Agora vamos deixar nosso pop-up mais agradável inserindo a mensagem de erro, um título, entre outras informações em nosso HTML,
Mas lembrese, esse objeto terá que ser ajustando em nosso error.interceptor.ts
<h2 mat-dialog-title>Ops, ocorreu um erro</h2>
<mat-dialog-content> <b>{{data.code}}</b> - {{data.message}}</mat-dialog-content>

Agora vamos ajustar nosso error.interceptor.ts para criar o objeto com as 2 propriedades:
import { Injectable } from '@angular/core';
import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpResponse, HttpErrorResponse } from '@angular/common/http';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/operator/do';
import { RequestErrorComponent } from './request-error.component';
import { MatDialog } from '@angular/material';
import { Router } from '@angular/router';

@Injectable()
export class ErrorInterceptor implements HttpInterceptor {

  constructor(private dialog:MatDialog, private _router:Router) { }
  
  intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    
    return next.handle(request).do((event: HttpEvent<any>) => {}, (err: any) => {
      if (err instanceof HttpErrorResponse) {
        if (err.status === 401) {
          this.openDialog({code:401, message:"Sessão expirada"});
          this._router.navigate(["/login"]);
        }
        this.openDialog({code:err.status, message:err.message})
      }else{
        this.openDialog({code:"Indisponível", message:"Não foi possível validar a causa do erro"})
      }
    });
  }

  private openDialog(info){
    this.dialog.open(RequestErrorComponent, {
      data: info
    });
  }

}

Vamos manter dessa forma até vinculamos de fato aos nossos serviços ai podemos ajustar nossa dialog de erro melhor, conforme as responses do servidor.


Com isto já temos nossa tratativa de erros, vamos agora criar um loading na tela main, para chamarmos quando necessário;
Há inumeras formas de fazer, por um Modulo de Loading, por um service com subscription, vou abordar da seguinte forma, vou incluir um novo service comum chamado
loading.service.ts onde vai ter a chamada que mudar o valor de sua variável e o component main, vai ficar escutando esta variável para mostrar o loading;
Então na pasta service, vou criar o loading.service.ts
import { Injectable } from '@angular/core';
import { Subject } from 'rxjs/Subject';

@Injectable()
export class LoadingService {
  public isLoading = false;
  public isLoadingChange = new Subject<Boolean>();
  constructor() { }
  public callNextStatus(status:boolean){
    this.isLoading = status;
    this.isLoadingChange.next(this.isLoading);
  }  
}

Agora vamos ajustar nosso main.module.ts para importar este provider, e também vamos importar o módulo referente ao progressBar
import {LoadingService} from '../services/loading.service'

import:[
    ...
    MatProgressBarModule
    ...
]
providers: [AuthGuard, LoadingService]

Agora vamos criar a subscription no main.component.ts para ficar observando essa váriavel do service.
import { Component, OnInit, ViewEncapsulation, OnDestroy } from '@angular/core';
import { LoadingService } from '../services/loading.service';
import { Subscription } from 'rxjs/Subscription';

@Component({
  selector: 'app-main',
  templateUrl: './main.component.html',
  styleUrls: ['./main.component.scss'],
  encapsulation: ViewEncapsulation.None
})
export class MainComponent implements OnInit,  OnDestroy {
 
  private isLoadingSubscription: Subscription;
  public loading:Boolean;

  constructor(private _loadingService:LoadingService) { }

  ngOnInit() {
    this.loading = this._loadingService.isLoading;
    this.isLoadingSubscription = this._loadingService.getLoading().subscribe(valor=>{      
       setTimeout(()=>{
        this.loading = valor;  
      },1);
    });
  }


  ngOnDestroy(){
    if(this.isLoadingSubscription) {
      this.isLoadingSubscription.unsubscribe();
    }
  }

}


Agora vamos ajustar nosso main.component.html para ter antes do conteudo esta progressBar:
<mat-progress-bar *ngIf="loading" color="warn" mode="indeterminate"></mat-progress-bar>
<mat-card id="content">
  <router-outlet></router-outlet>
</mat-card>

Não iremos importar nos módulos internos, o service, para não haver sobescrita do serviço para mantermos na mesma variável o status

Agora onde precisaremos do loading, vamos importar o serviço, LoadingService privado no contrutor, e chamarmos a função callNextStatus();
E vamos inserindo os loadings na aplicação onde acharmos necessário:





